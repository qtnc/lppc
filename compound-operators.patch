diff --git a/better-numbers.patch b/better-numbers.patch
deleted file mode 100644
index e6ebe08..0000000
--- a/better-numbers.patch
+++ /dev/null
@@ -1,116 +0,0 @@
-diff --git a/readme.md b/readme.md
-index 760cb2d..af8bfc9 100644
---- a/readme.md
-+++ b/readme.md
-@@ -19,6 +19,8 @@ Applying a patch is very easy:
- ### Compound operators
- Branch: compound-operators
- 
-+Download [compound-operators.patch] 
-+
- This patch adds the popular compound operators so well known and beloved in most other languages, that lua doesn't include by default.
- 
- - Add `+=, -=, *=, /=, //=, %=, ^=, |=, &=, <<=, >>=, ..=`
-@@ -41,6 +43,8 @@ print(t.u.v) -- 500
- ### Lambdas
- Branch: lambdas
- 
-+Download [lambdas.patch] ( 4 files changed, 89 insertions(+), 12 deletions(-))
-+
- This patch adds the support for shorter function syntax as known as lambdas, as it exists in other languages such as JavaScript, Java and Python.
- JavaScript's syntax with `=>` has been retained.
- 
-@@ -67,6 +71,8 @@ printcall( (a, b) => (b, a), 'one', 'two') -- two one
- ## Table extraction in local variables
- Branch: table-extract
- 
-+Download [table-extract.patch] ( 3 files changed, 39 insertions(+), 1 deletion(-))
-+
- This patch brings a little syntax suggar to extract multiple table fields into local variables at once.
- 
- - Add the syntax `local a, b, ... in expr `
-@@ -80,6 +86,8 @@ print(log(64, 2), floor(17.25), cos(0)) -- 6.0 17 1.0
- ### Syntax suggar for defining methods in tables
- Branch: methods-in-tables
- 
-+Download [methods-in-tables.patch] ( 2 files changed, 45 insertions(+), 3 deletions(-))
-+
- This patch brings a little syntax suggar to define methods in tables.
- 
- - Add method syntax in table (see below)
-@@ -110,6 +118,8 @@ print(mybank.balance) -- 1000
- ### Better numbers
- Branch: better-numbers
- 
-+Download [better-numbers.patch] ( 3 files changed, 29 insertions(+), 4 deletions(-))
-+
- This simple patch allows binary literals with 0b and thousend separators in  literals for better readability.
- 
- - Add underscore `_` thousend separator syntax in the code, e.g. `1_234_567` inspired by Java and JavaScript
-@@ -126,6 +136,8 @@ print(a+b) 1234575
- ### Default type metatable
- Branch: default-type-mt
- 
-+Download [default-type-mt.patch] ( 4 files changed, 66 insertions(+), 1 deletion(-))
-+
- You can call functions of the string table as methods without the need to do anything, because the type string has a shared metatable allowing it.
- Why don't tables do the same and allow to call table.insert, table.remove, table.sort, etc. as methods as well ?
- 
-@@ -150,6 +162,8 @@ print(t:concat(';')) -- 1;2;3;4;5
- ### Stared expand in table constructor
- Branch: star-expand
- 
-+Download [star-expand.patch] ( 4 files changed, 33 insertions(+), 9 deletions(-))
-+
- Well known by pythonists, this patch brings the unary `*` operator to lua, but it works only in table constructor to expand multiple arguments returned by a function. It's far from what Python allows, but better than nothing.
- 
- ```lua
-diff --git a/src/llex.c b/src/llex.c
-index 5fc39a5..4224d8e 100644
---- a/src/llex.c
-+++ b/src/llex.c
-@@ -235,11 +235,11 @@ static int read_numeral (LexState *ls, SemInfo *seminfo) {
-   for (;;) {
-     if (check_next2(ls, expo))  /* exponent mark? */
-       check_next2(ls, "-+");  /* optional exponent sign */
--    else if (lisxdigit(ls->current) || ls->current == '.')  /* '%x|%.' */
-+    else if (lisxdigit(ls->current) || ls->current == '.' || ls->current == '_')  /* '%x|%.' */
-       save_and_next(ls);
-     else break;
-   }
--  if (lislalpha(ls->current))  /* is numeral touching a letter? */
-+  if (lislalpha(ls->current) && ls->current != '_')  /* is numeral touching a letter? */
-     save_and_next(ls);  /* force an error */
-   save(ls, '\0');
-   if (luaO_str2num(luaZ_buffer(ls->buff), &obj) == 0)  /* format error? */
-diff --git a/src/lobject.c b/src/lobject.c
-index 9cfa522..68be38b 100644
---- a/src/lobject.c
-+++ b/src/lobject.c
-@@ -282,13 +282,24 @@ static const char *l_str2int (const char *s, lua_Integer *result) {
-   if (s[0] == '0' &&
-       (s[1] == 'x' || s[1] == 'X')) {  /* hex? */
-     s += 2;  /* skip '0x' */
--    for (; lisxdigit(cast_uchar(*s)); s++) {
-+    for (; lisxdigit(cast_uchar(*s)) || *s == '_'; s++) {
-+      if (*s == '_') continue;
-       a = a * 16 + luaO_hexavalue(*s);
-       empty = 0;
-     }
-   }
-+  else if (s[0] == '0' &&
-+      (s[1] == 'b' || s[1] == 'B')) {  /* binary? */
-+    s += 2;  /* skip '0x' */
-+    for (; *s == '0' || *s == '1' || *s == '_'; s++) {
-+      if (*s == '_') continue;
-+      a = a * 2 + (*s - '0');
-+      empty = 0;
-+    }
-+  }
-   else {  /* decimal */
--    for (; lisdigit(cast_uchar(*s)); s++) {
-+    for (; lisdigit(cast_uchar(*s)) || *s=='_'; s++) {
-+      if (*s == '_') continue;
-       int d = *s - '0';
-       if (a >= MAXBY10 && (a > MAXBY10 || d > MAXLASTD + neg))  /* overflow? */
-         return NULL;  /* do not accept it (as integer) */
diff --git a/compound-operators.patch b/compound-operators.patch
deleted file mode 100644
index 695c465..0000000
--- a/compound-operators.patch
+++ /dev/null
@@ -1,277 +0,0 @@
-diff --git a/readme.md b/readme.md
-index 760cb2d..af8bfc9 100644
---- a/readme.md
-+++ b/readme.md
-@@ -19,6 +19,8 @@ Applying a patch is very easy:
- ### Compound operators
- Branch: compound-operators
- 
-+Download [compound-operators.patch] 
-+
- This patch adds the popular compound operators so well known and beloved in most other languages, that lua doesn't include by default.
- 
- - Add `+=, -=, *=, /=, //=, %=, ^=, |=, &=, <<=, >>=, ..=`
-@@ -41,6 +43,8 @@ print(t.u.v) -- 500
- ### Lambdas
- Branch: lambdas
- 
-+Download [lambdas.patch] ( 4 files changed, 89 insertions(+), 12 deletions(-))
-+
- This patch adds the support for shorter function syntax as known as lambdas, as it exists in other languages such as JavaScript, Java and Python.
- JavaScript's syntax with `=>` has been retained.
- 
-@@ -67,6 +71,8 @@ printcall( (a, b) => (b, a), 'one', 'two') -- two one
- ## Table extraction in local variables
- Branch: table-extract
- 
-+Download [table-extract.patch] ( 3 files changed, 39 insertions(+), 1 deletion(-))
-+
- This patch brings a little syntax suggar to extract multiple table fields into local variables at once.
- 
- - Add the syntax `local a, b, ... in expr `
-@@ -80,6 +86,8 @@ print(log(64, 2), floor(17.25), cos(0)) -- 6.0 17 1.0
- ### Syntax suggar for defining methods in tables
- Branch: methods-in-tables
- 
-+Download [methods-in-tables.patch] ( 2 files changed, 45 insertions(+), 3 deletions(-))
-+
- This patch brings a little syntax suggar to define methods in tables.
- 
- - Add method syntax in table (see below)
-@@ -110,6 +118,8 @@ print(mybank.balance) -- 1000
- ### Better numbers
- Branch: better-numbers
- 
-+Download [better-numbers.patch] ( 3 files changed, 29 insertions(+), 4 deletions(-))
-+
- This simple patch allows binary literals with 0b and thousend separators in  literals for better readability.
- 
- - Add underscore `_` thousend separator syntax in the code, e.g. `1_234_567` inspired by Java and JavaScript
-@@ -126,6 +136,8 @@ print(a+b) 1234575
- ### Default type metatable
- Branch: default-type-mt
- 
-+Download [default-type-mt.patch] ( 4 files changed, 66 insertions(+), 1 deletion(-))
-+
- You can call functions of the string table as methods without the need to do anything, because the type string has a shared metatable allowing it.
- Why don't tables do the same and allow to call table.insert, table.remove, table.sort, etc. as methods as well ?
- 
-@@ -150,6 +162,8 @@ print(t:concat(';')) -- 1;2;3;4;5
- ### Stared expand in table constructor
- Branch: star-expand
- 
-+Download [star-expand.patch] ( 4 files changed, 33 insertions(+), 9 deletions(-))
-+
- Well known by pythonists, this patch brings the unary `*` operator to lua, but it works only in table constructor to expand multiple arguments returned by a function. It's far from what Python allows, but better than nothing.
- 
- ```lua
-diff --git a/src/llex.c b/src/llex.c
-index 5fc39a5..2c59df0 100644
---- a/src/llex.c
-+++ b/src/llex.c
-@@ -43,7 +43,10 @@ static const char *const luaX_tokens [] = {
-     "in", "local", "nil", "not", "or", "repeat",
-     "return", "then", "true", "until", "while",
-     "//", "..", "...", "==", ">=", "<=", "~=",
--    "<<", ">>", "::", "<eof>",
-+    "<<", ">>",
-+    "+=", "-=", "*=", "/=", "//=", "%=", "^=", "..=",
-+    "|=", "&=", "~=", "<<=", ">>=", "||=", "&&=",
-+    "::", "<eof>",
-     "<number>", "<integer>", "<name>", "<string>"
- };
- 
-@@ -456,7 +459,10 @@ static int llex (LexState *ls, SemInfo *seminfo) {
-       }
-       case '-': {  /* '-' or '--' (comment) */
-         next(ls);
--        if (ls->current != '-') return '-';
-+        if (ls->current != '-') {
-+        if (check_next1(ls, '=')) return TK_SUBAS;  /* '-=' */
-+        else return '-';
-+}
-         /* else is a comment */
-         next(ls);
-         if (ls->current == '[') {  /* long comment? */
-@@ -491,31 +497,84 @@ static int llex (LexState *ls, SemInfo *seminfo) {
-       case '<': {
-         next(ls);
-         if (check_next1(ls, '=')) return TK_LE;  /* '<=' */
--        else if (check_next1(ls, '<')) return TK_SHL;  /* '<<' */
-+        else if (check_next1(ls, '<')) {
-+if (check_next1(ls, '=')) return TK_SHLAS; /* '<<=' */
-+else return TK_SHL;  /* '<<' */
-+}
-         else return '<';
-       }
-       case '>': {
-         next(ls);
-         if (check_next1(ls, '=')) return TK_GE;  /* '>=' */
--        else if (check_next1(ls, '>')) return TK_SHR;  /* '>>' */
-+        else if (check_next1(ls, '>')) {
-+if (check_next1(ls, '=')) return TK_SHRAS; /* '>>=' */
-+else return TK_SHR;  /* '>>' */
-+}
-         else return '>';
-       }
-       case '/': {
-         next(ls);
--        if (check_next1(ls, '/')) return TK_IDIV;  /* '//' */
--        else return '/';
-+        if (check_next1(ls, '/')) {
-+if (check_next1(ls, '=')) return TK_IDIVAS; /* '//=' */
-+else return TK_IDIV;  /* '//' */
-+}
-+        else if (check_next1(ls, '=')) return TK_DIVAS; /* '/=' */
-+else return '/';
-       }
-       case '~': {
-         next(ls);
-         if (check_next1(ls, '=')) return TK_NE;  /* '~=' */
-         else return '~';
-       }
-+      case '!': {
-+        next(ls);
-+        if (check_next1(ls, '=')) return TK_NE;  /* '!=' */
-+        else return TK_NOT;
-+      }
-+      case '&': {
-+        next(ls);
-+        if (check_next1(ls, '&')) {
-+if (check_next1(ls, '=')) return TK_ANDAS; /* '&&=' */
-+else return TK_AND;  /* '&&' */
-+}
-+else if (check_next1(ls, '=')) return TK_BANDAS; /* '&=' */
-+        else return '&';
-+      }
-+      case '|': {
-+        next(ls);
-+        if (check_next1(ls, '|')) {
-+if (check_next1(ls, '=')) return TK_ORAS; /* '||=' */
-+else return TK_OR;  /* '||' */
-+}
-+else if (check_next1(ls, '=')) return TK_BORAS; /* '|=' */
-+        else return '|';
-+      }
-+      case '+': {
-+        next(ls);
-+        if (check_next1(ls, '=')) return TK_ADDAS;  /* '+=' */
-+        else return '+';
-+      }
-+      case '*': {
-+        next(ls);
-+        if (check_next1(ls, '=')) return TK_MULAS;  /* '*=' */
-+        else return '*';
-+      }
-+      case '%': {
-+        next(ls);
-+        if (check_next1(ls, '=')) return TK_MODAS;  /* '%=' */
-+        else return '%';
-+      }
-+      case '^': {
-+        next(ls);
-+        if (check_next1(ls, '=')) return TK_POWAS;  /* '^=' */
-+        else return '^';
-+      }
-       case ':': {
-         next(ls);
-         if (check_next1(ls, ':')) return TK_DBCOLON;  /* '::' */
-         else return ':';
-       }
--      case '"': case '\'': {  /* short literal strings */
-+      case '"': case '\'': case '`': {  /* short literal strings */
-         read_string(ls, ls->current, seminfo);
-         return TK_STRING;
-       }
-@@ -524,6 +583,7 @@ static int llex (LexState *ls, SemInfo *seminfo) {
-         if (check_next1(ls, '.')) {
-           if (check_next1(ls, '.'))
-             return TK_DOTS;   /* '...' */
-+else if (check_next1(ls, '=')) return TK_CONCATAS; /* '..=' */
-           else return TK_CONCAT;   /* '..' */
-         }
-         else if (!lisdigit(ls->current)) return '.';
-diff --git a/src/llex.h b/src/llex.h
-index 389d2f8..df2cba9 100644
---- a/src/llex.h
-+++ b/src/llex.h
-@@ -38,6 +38,8 @@ enum RESERVED {
-   /* other terminal symbols */
-   TK_IDIV, TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE,
-   TK_SHL, TK_SHR,
-+  TK_COMPOUND_FIRST, TK_ADDAS=TK_COMPOUND_FIRST, TK_SUBAS, TK_MULAS, TK_DIVAS, TK_IDIVAS, TK_MODAS, TK_POWAS, TK_CONCATAS,
-+  TK_BORAS, TK_BANDAS, TK_BXORAS, TK_SHLAS, TK_SHRAS, TK_ORAS, TK_ANDAS, TK_COMPOUND_LAST=TK_ANDAS,
-   TK_DBCOLON, TK_EOS,
-   TK_FLT, TK_INT, TK_NAME, TK_STRING
- };
-diff --git a/src/lparser.c b/src/lparser.c
-index 2b888c7..e9946cc 100644
---- a/src/lparser.c
-+++ b/src/lparser.c
-@@ -1402,6 +1402,55 @@ static void restassign (LexState *ls, struct LHS_assign *lh, int nvars) {
-   luaK_storevar(ls->fs, &lh->v, &e);
- }
- 
-+static BinOpr getcompoundbinopr (int op) {
-+  switch (op) {
-+    case TK_ADDAS: return OPR_ADD;
-+    case TK_SUBAS: return OPR_SUB;
-+    case TK_MULAS: return OPR_MUL;
-+    case TK_MODAS: return OPR_MOD;
-+    case TK_POWAS: return OPR_POW;
-+    case TK_DIVAS: return OPR_DIV;
-+    case TK_IDIVAS: return OPR_IDIV;
-+    case TK_BANDAS: return OPR_BAND;
-+    case TK_BORAS: return OPR_BOR;
-+    case TK_BXORAS: return OPR_BXOR;
-+    case TK_SHLAS: return OPR_SHL;
-+    case TK_SHRAS: return OPR_SHR;
-+    case TK_CONCATAS: return OPR_CONCAT;
-+    case TK_ANDAS: return OPR_AND;
-+    case TK_ORAS: return OPR_OR;
-+    default: return OPR_NOBINOPR;
-+  }
-+}
-+
-+
-+static void dupifneeded (LexState* ls, expdesc* src, expdesc* dst) {
-+int i = ls->fs->pc;
-+Instruction inst = i>0? ls->fs->f->code[i -1] :0;
-+int regdst, op = GET_OPCODE(inst);
-+if (i>0 && op>=OP_GETTABUP  && op<=OP_GETFIELD) {
-+  regdst = ls->fs->freereg; 
-+luaK_reserveregs(ls->fs, 1);
-+inst = SETARG_A(inst, regdst);
-+luaK_code(ls->fs, inst);
-+}
-+}
-+
-+static void compoundassign (LexState *ls, struct LHS_assign *lh, int tk) {
-+  expdesc e, r = lh->v;
-+  BinOpr opr = getcompoundbinopr(tk);
-+  check_condition(ls, vkisvar(lh->v.k), "syntax error");
-+  check_readonly(ls, &lh->v);
-+    checknext(ls, tk);
-+enterlevel(ls);
-+dupifneeded(ls, &lh->v, &r);
-+  luaK_infix(ls->fs, opr, &r);
-+    expr(ls, &e);
-+    luaK_posfix(ls->fs, opr, &r, &e, ls->linenumber);
-+leavelevel(ls);
-+      luaK_storevar(ls->fs, &lh->v, &r);
-+}
-+
- 
- static int cond (LexState *ls) {
-   /* cond -> exp */
-@@ -1801,6 +1850,10 @@ static void exprstat (LexState *ls) {
-     v.prev = NULL;
-     restassign(ls, &v, 1);
-   }
-+  else if (ls->t.token >= TK_COMPOUND_FIRST && ls->t.token <= TK_COMPOUND_LAST) { /* stat -> compound assignment ? */
-+    v.prev = NULL;
-+    compoundassign(ls, &v, ls->t.token);
-+  }
-   else {  /* stat -> func */
-     Instruction *inst;
-     check_condition(ls, v.v.k == VCALL, "syntax error");
diff --git a/default-type-mt.patch b/default-type-mt.patch
deleted file mode 100644
index e0a3b13..0000000
--- a/default-type-mt.patch
+++ /dev/null
@@ -1,174 +0,0 @@
-diff --git a/readme.md b/readme.md
-index 760cb2d..af8bfc9 100644
---- a/readme.md
-+++ b/readme.md
-@@ -19,6 +19,8 @@ Applying a patch is very easy:
- ### Compound operators
- Branch: compound-operators
- 
-+Download [compound-operators.patch] 
-+
- This patch adds the popular compound operators so well known and beloved in most other languages, that lua doesn't include by default.
- 
- - Add `+=, -=, *=, /=, //=, %=, ^=, |=, &=, <<=, >>=, ..=`
-@@ -41,6 +43,8 @@ print(t.u.v) -- 500
- ### Lambdas
- Branch: lambdas
- 
-+Download [lambdas.patch] ( 4 files changed, 89 insertions(+), 12 deletions(-))
-+
- This patch adds the support for shorter function syntax as known as lambdas, as it exists in other languages such as JavaScript, Java and Python.
- JavaScript's syntax with `=>` has been retained.
- 
-@@ -67,6 +71,8 @@ printcall( (a, b) => (b, a), 'one', 'two') -- two one
- ## Table extraction in local variables
- Branch: table-extract
- 
-+Download [table-extract.patch] ( 3 files changed, 39 insertions(+), 1 deletion(-))
-+
- This patch brings a little syntax suggar to extract multiple table fields into local variables at once.
- 
- - Add the syntax `local a, b, ... in expr `
-@@ -80,6 +86,8 @@ print(log(64, 2), floor(17.25), cos(0)) -- 6.0 17 1.0
- ### Syntax suggar for defining methods in tables
- Branch: methods-in-tables
- 
-+Download [methods-in-tables.patch] ( 2 files changed, 45 insertions(+), 3 deletions(-))
-+
- This patch brings a little syntax suggar to define methods in tables.
- 
- - Add method syntax in table (see below)
-@@ -110,6 +118,8 @@ print(mybank.balance) -- 1000
- ### Better numbers
- Branch: better-numbers
- 
-+Download [better-numbers.patch] ( 3 files changed, 29 insertions(+), 4 deletions(-))
-+
- This simple patch allows binary literals with 0b and thousend separators in  literals for better readability.
- 
- - Add underscore `_` thousend separator syntax in the code, e.g. `1_234_567` inspired by Java and JavaScript
-@@ -126,6 +136,8 @@ print(a+b) 1234575
- ### Default type metatable
- Branch: default-type-mt
- 
-+Download [default-type-mt.patch] ( 4 files changed, 66 insertions(+), 1 deletion(-))
-+
- You can call functions of the string table as methods without the need to do anything, because the type string has a shared metatable allowing it.
- Why don't tables do the same and allow to call table.insert, table.remove, table.sort, etc. as methods as well ?
- 
-@@ -150,6 +162,8 @@ print(t:concat(';')) -- 1;2;3;4;5
- ### Stared expand in table constructor
- Branch: star-expand
- 
-+Download [star-expand.patch] ( 4 files changed, 33 insertions(+), 9 deletions(-))
-+
- Well known by pythonists, this patch brings the unary `*` operator to lua, but it works only in table constructor to expand multiple arguments returned by a function. It's far from what Python allows, but better than nothing.
- 
- ```lua
-diff --git a/src/lapi.c b/src/lapi.c
-index 332e97d..752bdc0 100644
---- a/src/lapi.c
-+++ b/src/lapi.c
-@@ -798,6 +798,22 @@ LUA_API int lua_getmetatable (lua_State *L, int objindex) {
-   return res;
- }
- 
-+LUA_API int lua_gettypemetatable (lua_State *L, int type) {
-+  const TValue *obj;
-+  Table *mt;
-+  int res = 0;
-+  lua_lock(L);
-+  mt = G(L)->mt[type];
-+  if (mt != NULL) {
-+    sethvalue2s(L, L->top.p, mt);
-+    api_incr_top(L);
-+    res = 1;
-+  }
-+  lua_unlock(L);
-+  return res;
-+}
-+
-+
- 
- LUA_API int lua_getiuservalue (lua_State *L, int idx, int n) {
-   TValue *o;
-@@ -969,6 +985,22 @@ LUA_API int lua_setmetatable (lua_State *L, int objindex) {
-   return 1;
- }
- 
-+LUA_API int lua_settypemetatable (lua_State *L, int type) {
-+  Table *mt;
-+  lua_lock(L);
-+  api_checknelems(L, 1);
-+  if (ttisnil(s2v(L->top.p - 1)))
-+    mt = NULL;
-+  else {
-+    api_check(L, ttistable(s2v(L->top.p - 1)), "table expected");
-+    mt = hvalue(s2v(L->top.p - 1));
-+  }
-+  G(L)->mt[type] = mt;
-+  L->top.p--;
-+  lua_unlock(L);
-+  return 1;
-+}
-+
- 
- LUA_API int lua_setiuservalue (lua_State *L, int idx, int n) {
-   TValue *o;
-diff --git a/src/ldblib.c b/src/ldblib.c
-index 6dcbaa9..f1f3efd 100644
---- a/src/ldblib.c
-+++ b/src/ldblib.c
-@@ -61,6 +61,23 @@ static int db_setmetatable (lua_State *L) {
-   return 1;  /* return 1st argument */
- }
- 
-+static int db_gettypemetatable (lua_State *L) {
-+  luaL_checkany(L, 1);
-+  if (!lua_gettypemetatable(L, lua_type(L, 1))) {
-+    lua_pushnil(L);  /* no metatable */
-+  }
-+  return 1;
-+}
-+
-+
-+static int db_settypemetatable (lua_State *L) {
-+  int t = lua_type(L, 2);
-+  luaL_argexpected(L, t == LUA_TNIL || t == LUA_TTABLE, 2, "nil or table");
-+  lua_settop(L, 2);
-+  lua_settypemetatable(L, lua_type(L, 1));
-+  return 1;  /* return 1st argument */
-+}
-+
- 
- static int db_getuservalue (lua_State *L) {
-   int n = (int)luaL_optinteger(L, 2, 1);
-@@ -462,6 +479,7 @@ static const luaL_Reg dblib[] = {
-   {"getlocal", db_getlocal},
-   {"getregistry", db_getregistry},
-   {"getmetatable", db_getmetatable},
-+  {"gettypemetatable", db_gettypemetatable},
-   {"getupvalue", db_getupvalue},
-   {"upvaluejoin", db_upvaluejoin},
-   {"upvalueid", db_upvalueid},
-@@ -469,6 +487,7 @@ static const luaL_Reg dblib[] = {
-   {"sethook", db_sethook},
-   {"setlocal", db_setlocal},
-   {"setmetatable", db_setmetatable},
-+  {"settypemetatable", db_settypemetatable},
-   {"setupvalue", db_setupvalue},
-   {"traceback", db_traceback},
-   {"setcstacklimit", db_setcstacklimit},
-diff --git a/src/ltable.c b/src/ltable.c
-index 3353c04..d051c83 100644
---- a/src/ltable.c
-+++ b/src/ltable.c
-@@ -626,7 +626,7 @@ static void rehash (lua_State *L, Table *t, const TValue *ek) {
- Table *luaH_new (lua_State *L) {
-   GCObject *o = luaC_newobj(L, LUA_VTABLE, sizeof(Table));
-   Table *t = gco2t(o);
--  t->metatable = NULL;
-+  t->metatable = G(L)->mt[LUA_TTABLE];
-   t->flags = cast_byte(maskflags);  /* table has no metamethod fields */
-   t->array = NULL;
-   t->alimit = 0;
diff --git a/lambdas.patch b/lambdas.patch
deleted file mode 100644
index 7184af3..0000000
--- a/lambdas.patch
+++ /dev/null
@@ -1,266 +0,0 @@
-diff --git a/readme.md b/readme.md
-index 760cb2d..af8bfc9 100644
---- a/readme.md
-+++ b/readme.md
-@@ -19,6 +19,8 @@ Applying a patch is very easy:
- ### Compound operators
- Branch: compound-operators
- 
-+Download [compound-operators.patch] 
-+
- This patch adds the popular compound operators so well known and beloved in most other languages, that lua doesn't include by default.
- 
- - Add `+=, -=, *=, /=, //=, %=, ^=, |=, &=, <<=, >>=, ..=`
-@@ -41,6 +43,8 @@ print(t.u.v) -- 500
- ### Lambdas
- Branch: lambdas
- 
-+Download [lambdas.patch] ( 4 files changed, 89 insertions(+), 12 deletions(-))
-+
- This patch adds the support for shorter function syntax as known as lambdas, as it exists in other languages such as JavaScript, Java and Python.
- JavaScript's syntax with `=>` has been retained.
- 
-@@ -67,6 +71,8 @@ printcall( (a, b) => (b, a), 'one', 'two') -- two one
- ## Table extraction in local variables
- Branch: table-extract
- 
-+Download [table-extract.patch] ( 3 files changed, 39 insertions(+), 1 deletion(-))
-+
- This patch brings a little syntax suggar to extract multiple table fields into local variables at once.
- 
- - Add the syntax `local a, b, ... in expr `
-@@ -80,6 +86,8 @@ print(log(64, 2), floor(17.25), cos(0)) -- 6.0 17 1.0
- ### Syntax suggar for defining methods in tables
- Branch: methods-in-tables
- 
-+Download [methods-in-tables.patch] ( 2 files changed, 45 insertions(+), 3 deletions(-))
-+
- This patch brings a little syntax suggar to define methods in tables.
- 
- - Add method syntax in table (see below)
-@@ -110,6 +118,8 @@ print(mybank.balance) -- 1000
- ### Better numbers
- Branch: better-numbers
- 
-+Download [better-numbers.patch] ( 3 files changed, 29 insertions(+), 4 deletions(-))
-+
- This simple patch allows binary literals with 0b and thousend separators in  literals for better readability.
- 
- - Add underscore `_` thousend separator syntax in the code, e.g. `1_234_567` inspired by Java and JavaScript
-@@ -126,6 +136,8 @@ print(a+b) 1234575
- ### Default type metatable
- Branch: default-type-mt
- 
-+Download [default-type-mt.patch] ( 4 files changed, 66 insertions(+), 1 deletion(-))
-+
- You can call functions of the string table as methods without the need to do anything, because the type string has a shared metatable allowing it.
- Why don't tables do the same and allow to call table.insert, table.remove, table.sort, etc. as methods as well ?
- 
-@@ -150,6 +162,8 @@ print(t:concat(';')) -- 1;2;3;4;5
- ### Stared expand in table constructor
- Branch: star-expand
- 
-+Download [star-expand.patch] ( 4 files changed, 33 insertions(+), 9 deletions(-))
-+
- Well known by pythonists, this patch brings the unary `*` operator to lua, but it works only in table constructor to expand multiple arguments returned by a function. It's far from what Python allows, but better than nothing.
- 
- ```lua
-diff --git a/src/llex.c b/src/llex.c
-index 5fc39a5..ac79c27 100644
---- a/src/llex.c
-+++ b/src/llex.c
-@@ -42,6 +42,7 @@ static const char *const luaX_tokens [] = {
-     "end", "false", "for", "function", "goto", "if",
-     "in", "local", "nil", "not", "or", "repeat",
-     "return", "then", "true", "until", "while",
-+    "=>", 
-     "//", "..", "...", "==", ">=", "<=", "~=",
-     "<<", ">>", "::", "<eof>",
-     "<number>", "<integer>", "<name>", "<string>"
-@@ -170,6 +171,8 @@ void luaX_setinput (lua_State *L, LexState *ls, ZIO *z, TString *source,
-   ls->L = L;
-   ls->current = firstchar;
-   ls->lookahead.token = TK_EOS;  /* no look-ahead token */
-+  ls->lookahead2.token = TK_EOS;  /* no look-ahead token */
-+  ls->lookahead3.token = TK_EOS;  /* no look-ahead token */
-   ls->z = z;
-   ls->fs = NULL;
-   ls->linenumber = 1;
-@@ -486,6 +489,7 @@ static int llex (LexState *ls, SemInfo *seminfo) {
-       case '=': {
-         next(ls);
-         if (check_next1(ls, '=')) return TK_EQ;  /* '==' */
-+        else if (check_next1(ls, '>')) return TK_RARROW;  /* '=>' */
-         else return '=';
-       }
-       case '<': {
-@@ -566,7 +570,9 @@ void luaX_next (LexState *ls) {
-   ls->lastline = ls->linenumber;
-   if (ls->lookahead.token != TK_EOS) {  /* is there a look-ahead token? */
-     ls->t = ls->lookahead;  /* use this one */
--    ls->lookahead.token = TK_EOS;  /* and discharge it */
-+    ls->lookahead = ls->lookahead2;
-+    ls->lookahead2 = ls->lookahead3;
-+    ls->lookahead3.token = TK_EOS;  /* and discharge it */
-   }
-   else
-     ls->t.token = llex(ls, &ls->t.seminfo);  /* read next token */
-@@ -574,8 +580,9 @@ void luaX_next (LexState *ls) {
- 
- 
- int luaX_lookahead (LexState *ls) {
--  lua_assert(ls->lookahead.token == TK_EOS);
--  ls->lookahead.token = llex(ls, &ls->lookahead.seminfo);
--  return ls->lookahead.token;
-+  lua_assert(ls->lookahead3.token == TK_EOS);
-+  Token* t = ls->lookahead.token == TK_EOS ? &ls->lookahead : (ls->lookahead2.token == TK_EOS? &ls->lookahead2 : &ls->lookahead3);
-+  t->token = llex(ls, &t->seminfo);
-+  return t->token;
- }
- 
-diff --git a/src/llex.h b/src/llex.h
-index 389d2f8..66dd9b8 100644
---- a/src/llex.h
-+++ b/src/llex.h
-@@ -36,6 +36,7 @@ enum RESERVED {
-   TK_GOTO, TK_IF, TK_IN, TK_LOCAL, TK_NIL, TK_NOT, TK_OR, TK_REPEAT,
-   TK_RETURN, TK_THEN, TK_TRUE, TK_UNTIL, TK_WHILE,
-   /* other terminal symbols */
-+  TK_RARROW,
-   TK_IDIV, TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE,
-   TK_SHL, TK_SHR,
-   TK_DBCOLON, TK_EOS,
-@@ -67,6 +68,8 @@ typedef struct LexState {
-   int lastline;  /* line of last token 'consumed' */
-   Token t;  /* current token */
-   Token lookahead;  /* look ahead token */
-+  Token lookahead2;  /* look ahead token */
-+  Token lookahead3;  /* look ahead token */
-   struct FuncState *fs;  /* current function (parser) */
-   struct lua_State *L;
-   ZIO *z;  /* input stream */
-diff --git a/src/lparser.c b/src/lparser.c
-index 2b888c7..38fe2a7 100644
---- a/src/lparser.c
-+++ b/src/lparser.c
-@@ -956,13 +956,16 @@ static void setvararg (FuncState *fs, int nparams) {
- }
- 
- 
--static void parlist (LexState *ls) {
-+static void parlist (LexState *ls, int parens) {
-   /* parlist -> [ {NAME ','} (NAME | '...') ] */
-   FuncState *fs = ls->fs;
-   Proto *f = fs->f;
-   int nparams = 0;
-   int isvararg = 0;
--  if (ls->t.token != ')') {  /* is 'parlist' not empty? */
-+  if (
-+    (parens && ls->t.token != ')') 
-+    || (!parens && ls->t.token != TK_RARROW && ls->t.token != '{')
-+  ) {  /* is 'parlist' not empty? */
-     do {
-       switch (ls->t.token) {
-         case TK_NAME: {
-@@ -986,24 +989,31 @@ static void parlist (LexState *ls) {
-   luaK_reserveregs(fs, fs->nactvar);  /* reserve registers for parameters */
- }
- 
-+static void singleretstat (LexState* ls);
- 
- static void body (LexState *ls, expdesc *e, int ismethod, int line) {
-   /* body ->  '(' parlist ')' block END */
-   FuncState new_fs;
-   BlockCnt bl;
-+  int parens;
-   new_fs.f = addprototype(ls);
-   new_fs.f->linedefined = line;
-   open_func(ls, &new_fs, &bl);
--  checknext(ls, '(');
-+  parens = testnext(ls, '(');
-   if (ismethod) {
-     new_localvarliteral(ls, "self");  /* create 'self' parameter */
-     adjustlocalvars(ls, 1);
-   }
--  parlist(ls);
--  checknext(ls, ')');
--  statlist(ls);
--  new_fs.f->lastlinedefined = ls->linenumber;
--  check_match(ls, TK_END, TK_FUNCTION, line);
-+  parlist(ls, parens);
-+  if (parens) checknext(ls, ')');
-+  if (testnext(ls, TK_RARROW)) {
-+    singleretstat(ls);
-+   new_fs.f->lastlinedefined = ls->linenumber;
-+  } else {
-+    statlist(ls);
-+    new_fs.f->lastlinedefined = ls->linenumber;
-+    check_match(ls, TK_END, TK_FUNCTION, line);
-+  }
-   codeclosure(ls, e);
-   close_func(ls);
- }
-@@ -1136,6 +1146,16 @@ static void suffixedexp (LexState *ls, expdesc *v) {
-   }
- }
- 
-+static int testlambdadecl (LexState* ls) {
-+int tk = luaX_lookahead(ls);
-+  if (tk == ')') return 1;
-+  else if (tk != TK_NAME) return 0;
-+  tk = luaX_lookahead(ls);
-+  if (tk == ',') return 1;
-+  else if (tk != ')') return 0;
-+  tk = luaX_lookahead(ls);
-+  return tk == TK_RARROW;
-+}
- 
- static void simpleexp (LexState *ls, expdesc *v) {
-   /* simpleexp -> FLT | INT | STRING | NIL | TRUE | FALSE | ... |
-@@ -1183,6 +1203,24 @@ static void simpleexp (LexState *ls, expdesc *v) {
-       body(ls, v, 0, ls->linenumber);
-       return;
-     }
-+    case TK_RARROW: {
-+      body(ls, v, 0, ls->linenumber);
-+      return;
-+    }
-+    case TK_NAME: {
-+      if (luaX_lookahead(ls) == TK_RARROW)
-+        body(ls, v, 0, ls->linenumber);
-+      else
-+        suffixedexp(ls, v);
-+      return;
-+    }
-+    case '(': {
-+      if (testlambdadecl(ls)) 
-+        body(ls, v, 0, ls->linenumber);
-+      else
-+        suffixedexp(ls, v);
-+      return;
-+    }
-     default: {
-       suffixedexp(ls, v);
-       return;
-@@ -1841,6 +1879,21 @@ static void retstat (LexState *ls) {
-   testnext(ls, ';');  /* skip optional semicolon */
- }
- 
-+static void singleretstat (LexState* ls) {
-+expdesc e;
-+int line = ls->linenumber;
-+if (testnext(ls, '(')) {
-+retstat(ls);
-+check_match(ls, ')', '(', line);
-+}
-+else {
-+expr(ls, &e);
-+  int first = luaY_nvarstack(ls->fs);  /* first slot to be returned */
-+        first = luaK_exp2anyreg(ls->fs, &e);  /* can use original slot */
-+  luaK_ret(ls->fs, first, 1);
-+}
-+}
-+
- 
- static void statement (LexState *ls) {
-   int line = ls->linenumber;  /* may be needed for error messages */
diff --git a/methods-in-tables.patch b/methods-in-tables.patch
deleted file mode 100644
index 8a17a90..0000000
--- a/methods-in-tables.patch
+++ /dev/null
@@ -1,146 +0,0 @@
-diff --git a/readme.md b/readme.md
-index 760cb2d..af8bfc9 100644
---- a/readme.md
-+++ b/readme.md
-@@ -19,6 +19,8 @@ Applying a patch is very easy:
- ### Compound operators
- Branch: compound-operators
- 
-+Download [compound-operators.patch] 
-+
- This patch adds the popular compound operators so well known and beloved in most other languages, that lua doesn't include by default.
- 
- - Add `+=, -=, *=, /=, //=, %=, ^=, |=, &=, <<=, >>=, ..=`
-@@ -41,6 +43,8 @@ print(t.u.v) -- 500
- ### Lambdas
- Branch: lambdas
- 
-+Download [lambdas.patch] ( 4 files changed, 89 insertions(+), 12 deletions(-))
-+
- This patch adds the support for shorter function syntax as known as lambdas, as it exists in other languages such as JavaScript, Java and Python.
- JavaScript's syntax with `=>` has been retained.
- 
-@@ -67,6 +71,8 @@ printcall( (a, b) => (b, a), 'one', 'two') -- two one
- ## Table extraction in local variables
- Branch: table-extract
- 
-+Download [table-extract.patch] ( 3 files changed, 39 insertions(+), 1 deletion(-))
-+
- This patch brings a little syntax suggar to extract multiple table fields into local variables at once.
- 
- - Add the syntax `local a, b, ... in expr `
-@@ -80,6 +86,8 @@ print(log(64, 2), floor(17.25), cos(0)) -- 6.0 17 1.0
- ### Syntax suggar for defining methods in tables
- Branch: methods-in-tables
- 
-+Download [methods-in-tables.patch] ( 2 files changed, 45 insertions(+), 3 deletions(-))
-+
- This patch brings a little syntax suggar to define methods in tables.
- 
- - Add method syntax in table (see below)
-@@ -110,6 +118,8 @@ print(mybank.balance) -- 1000
- ### Better numbers
- Branch: better-numbers
- 
-+Download [better-numbers.patch] ( 3 files changed, 29 insertions(+), 4 deletions(-))
-+
- This simple patch allows binary literals with 0b and thousend separators in  literals for better readability.
- 
- - Add underscore `_` thousend separator syntax in the code, e.g. `1_234_567` inspired by Java and JavaScript
-@@ -126,6 +136,8 @@ print(a+b) 1234575
- ### Default type metatable
- Branch: default-type-mt
- 
-+Download [default-type-mt.patch] ( 4 files changed, 66 insertions(+), 1 deletion(-))
-+
- You can call functions of the string table as methods without the need to do anything, because the type string has a shared metatable allowing it.
- Why don't tables do the same and allow to call table.insert, table.remove, table.sort, etc. as methods as well ?
- 
-@@ -150,6 +162,8 @@ print(t:concat(';')) -- 1;2;3;4;5
- ### Stared expand in table constructor
- Branch: star-expand
- 
-+Download [star-expand.patch] ( 4 files changed, 33 insertions(+), 9 deletions(-))
-+
- Well known by pythonists, this patch brings the unary `*` operator to lua, but it works only in table constructor to expand multiple arguments returned by a function. It's far from what Python allows, but better than nothing.
- 
- ```lua
-diff --git a/src/lparser.c b/src/lparser.c
-index 2b888c7..0dae4bd 100644
---- a/src/lparser.c
-+++ b/src/lparser.c
-@@ -864,6 +864,24 @@ static void recfield (LexState *ls, ConsControl *cc) {
-   fs->freereg = reg;  /* free registers */
- }
- 
-+static void body (LexState *ls, expdesc *e, int ismethod, int line);
-+
-+static int funcfield (LexState *ls, ConsControl *cc) {
-+  /* funcfield -> FUNCTION funcname body */
-+  FuncState *fs = ls->fs;
-+  int reg = ls->fs->freereg;
-+  expdesc tab, key, b;
-+  luaX_next(ls);  /* skip FUNCTION */
-+    checklimit(fs, cc->nh, MAX_INT, "items in a constructor");
-+    codename(ls, &key);
-+  cc->nh++;
-+  tab = *cc->t;
-+  luaK_indexed(fs, &tab, &key);
-+  body(ls, &b, 1, ls->linenumber);
-+  luaK_storevar(fs, &tab, &b);
-+  fs->freereg = reg;  /* free registers */
-+  return 1;
-+}
- 
- static void closelistfield (FuncState *fs, ConsControl *cc) {
-   if (cc->v.k == VVOID) return;  /* there is no list item */
-@@ -900,8 +918,9 @@ static void listfield (LexState *ls, ConsControl *cc) {
- }
- 
- 
--static void field (LexState *ls, ConsControl *cc) {
-+static int field (LexState *ls, ConsControl *cc) {
-   /* field -> listfield | recfield */
-+  int nocomma = 0;
-   switch(ls->t.token) {
-     case TK_NAME: {  /* may be 'listfield' or 'recfield' */
-       if (luaX_lookahead(ls) != '=')  /* expression? */
-@@ -914,11 +933,19 @@ static void field (LexState *ls, ConsControl *cc) {
-       recfield(ls, cc);
-       break;
-     }
-+    case TK_FUNCTION: {
-+      if (luaX_lookahead(ls) != TK_NAME)  
-+        listfield(ls, cc);
-+      else
-+        nocomma = funcfield(ls, cc);
-+      break;
-+    }
-     default: {
-       listfield(ls, cc);
-       break;
-     }
-   }
-+  return nocomma;
- }
- 
- 
-@@ -928,6 +955,7 @@ static void constructor (LexState *ls, expdesc *t) {
-   FuncState *fs = ls->fs;
-   int line = ls->linenumber;
-   int pc = luaK_codeABC(fs, OP_NEWTABLE, 0, 0, 0);
-+  int nocomma = 0;
-   ConsControl cc;
-   luaK_code(fs, 0);  /* space for extra arg. */
-   cc.na = cc.nh = cc.tostore = 0;
-@@ -940,8 +968,8 @@ static void constructor (LexState *ls, expdesc *t) {
-     lua_assert(cc.v.k == VVOID || cc.tostore > 0);
-     if (ls->t.token == '}') break;
-     closelistfield(fs, &cc);
--    field(ls, &cc);
--  } while (testnext(ls, ',') || testnext(ls, ';'));
-+    nocomma = field(ls, &cc);
-+  } while (testnext(ls, ',') || testnext(ls, ';') || nocomma);
-   check_match(ls, '}', '{', line);
-   lastlistfield(fs, &cc);
-   luaK_settablesize(fs, pc, t->u.info, cc.na, cc.nh);
diff --git a/src/llex.c b/src/llex.c
index 5fc39a5..2c59df0 100644
--- a/src/llex.c
+++ b/src/llex.c
@@ -43,7 +43,10 @@ static const char *const luaX_tokens [] = {
     "in", "local", "nil", "not", "or", "repeat",
     "return", "then", "true", "until", "while",
     "//", "..", "...", "==", ">=", "<=", "~=",
-    "<<", ">>", "::", "<eof>",
+    "<<", ">>",
+    "+=", "-=", "*=", "/=", "//=", "%=", "^=", "..=",
+    "|=", "&=", "~=", "<<=", ">>=", "||=", "&&=",
+    "::", "<eof>",
     "<number>", "<integer>", "<name>", "<string>"
 };
 
@@ -456,7 +459,10 @@ static int llex (LexState *ls, SemInfo *seminfo) {
       }
       case '-': {  /* '-' or '--' (comment) */
         next(ls);
-        if (ls->current != '-') return '-';
+        if (ls->current != '-') {
+        if (check_next1(ls, '=')) return TK_SUBAS;  /* '-=' */
+        else return '-';
+}
         /* else is a comment */
         next(ls);
         if (ls->current == '[') {  /* long comment? */
@@ -491,31 +497,84 @@ static int llex (LexState *ls, SemInfo *seminfo) {
       case '<': {
         next(ls);
         if (check_next1(ls, '=')) return TK_LE;  /* '<=' */
-        else if (check_next1(ls, '<')) return TK_SHL;  /* '<<' */
+        else if (check_next1(ls, '<')) {
+if (check_next1(ls, '=')) return TK_SHLAS; /* '<<=' */
+else return TK_SHL;  /* '<<' */
+}
         else return '<';
       }
       case '>': {
         next(ls);
         if (check_next1(ls, '=')) return TK_GE;  /* '>=' */
-        else if (check_next1(ls, '>')) return TK_SHR;  /* '>>' */
+        else if (check_next1(ls, '>')) {
+if (check_next1(ls, '=')) return TK_SHRAS; /* '>>=' */
+else return TK_SHR;  /* '>>' */
+}
         else return '>';
       }
       case '/': {
         next(ls);
-        if (check_next1(ls, '/')) return TK_IDIV;  /* '//' */
-        else return '/';
+        if (check_next1(ls, '/')) {
+if (check_next1(ls, '=')) return TK_IDIVAS; /* '//=' */
+else return TK_IDIV;  /* '//' */
+}
+        else if (check_next1(ls, '=')) return TK_DIVAS; /* '/=' */
+else return '/';
       }
       case '~': {
         next(ls);
         if (check_next1(ls, '=')) return TK_NE;  /* '~=' */
         else return '~';
       }
+      case '!': {
+        next(ls);
+        if (check_next1(ls, '=')) return TK_NE;  /* '!=' */
+        else return TK_NOT;
+      }
+      case '&': {
+        next(ls);
+        if (check_next1(ls, '&')) {
+if (check_next1(ls, '=')) return TK_ANDAS; /* '&&=' */
+else return TK_AND;  /* '&&' */
+}
+else if (check_next1(ls, '=')) return TK_BANDAS; /* '&=' */
+        else return '&';
+      }
+      case '|': {
+        next(ls);
+        if (check_next1(ls, '|')) {
+if (check_next1(ls, '=')) return TK_ORAS; /* '||=' */
+else return TK_OR;  /* '||' */
+}
+else if (check_next1(ls, '=')) return TK_BORAS; /* '|=' */
+        else return '|';
+      }
+      case '+': {
+        next(ls);
+        if (check_next1(ls, '=')) return TK_ADDAS;  /* '+=' */
+        else return '+';
+      }
+      case '*': {
+        next(ls);
+        if (check_next1(ls, '=')) return TK_MULAS;  /* '*=' */
+        else return '*';
+      }
+      case '%': {
+        next(ls);
+        if (check_next1(ls, '=')) return TK_MODAS;  /* '%=' */
+        else return '%';
+      }
+      case '^': {
+        next(ls);
+        if (check_next1(ls, '=')) return TK_POWAS;  /* '^=' */
+        else return '^';
+      }
       case ':': {
         next(ls);
         if (check_next1(ls, ':')) return TK_DBCOLON;  /* '::' */
         else return ':';
       }
-      case '"': case '\'': {  /* short literal strings */
+      case '"': case '\'': case '`': {  /* short literal strings */
         read_string(ls, ls->current, seminfo);
         return TK_STRING;
       }
@@ -524,6 +583,7 @@ static int llex (LexState *ls, SemInfo *seminfo) {
         if (check_next1(ls, '.')) {
           if (check_next1(ls, '.'))
             return TK_DOTS;   /* '...' */
+else if (check_next1(ls, '=')) return TK_CONCATAS; /* '..=' */
           else return TK_CONCAT;   /* '..' */
         }
         else if (!lisdigit(ls->current)) return '.';
diff --git a/src/llex.h b/src/llex.h
index 389d2f8..df2cba9 100644
--- a/src/llex.h
+++ b/src/llex.h
@@ -38,6 +38,8 @@ enum RESERVED {
   /* other terminal symbols */
   TK_IDIV, TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE,
   TK_SHL, TK_SHR,
+  TK_COMPOUND_FIRST, TK_ADDAS=TK_COMPOUND_FIRST, TK_SUBAS, TK_MULAS, TK_DIVAS, TK_IDIVAS, TK_MODAS, TK_POWAS, TK_CONCATAS,
+  TK_BORAS, TK_BANDAS, TK_BXORAS, TK_SHLAS, TK_SHRAS, TK_ORAS, TK_ANDAS, TK_COMPOUND_LAST=TK_ANDAS,
   TK_DBCOLON, TK_EOS,
   TK_FLT, TK_INT, TK_NAME, TK_STRING
 };
diff --git a/src/lparser.c b/src/lparser.c
index 2b888c7..e9946cc 100644
--- a/src/lparser.c
+++ b/src/lparser.c
@@ -1402,6 +1402,55 @@ static void restassign (LexState *ls, struct LHS_assign *lh, int nvars) {
   luaK_storevar(ls->fs, &lh->v, &e);
 }
 
+static BinOpr getcompoundbinopr (int op) {
+  switch (op) {
+    case TK_ADDAS: return OPR_ADD;
+    case TK_SUBAS: return OPR_SUB;
+    case TK_MULAS: return OPR_MUL;
+    case TK_MODAS: return OPR_MOD;
+    case TK_POWAS: return OPR_POW;
+    case TK_DIVAS: return OPR_DIV;
+    case TK_IDIVAS: return OPR_IDIV;
+    case TK_BANDAS: return OPR_BAND;
+    case TK_BORAS: return OPR_BOR;
+    case TK_BXORAS: return OPR_BXOR;
+    case TK_SHLAS: return OPR_SHL;
+    case TK_SHRAS: return OPR_SHR;
+    case TK_CONCATAS: return OPR_CONCAT;
+    case TK_ANDAS: return OPR_AND;
+    case TK_ORAS: return OPR_OR;
+    default: return OPR_NOBINOPR;
+  }
+}
+
+
+static void dupifneeded (LexState* ls, expdesc* src, expdesc* dst) {
+int i = ls->fs->pc;
+Instruction inst = i>0? ls->fs->f->code[i -1] :0;
+int regdst, op = GET_OPCODE(inst);
+if (i>0 && op>=OP_GETTABUP  && op<=OP_GETFIELD) {
+  regdst = ls->fs->freereg; 
+luaK_reserveregs(ls->fs, 1);
+inst = SETARG_A(inst, regdst);
+luaK_code(ls->fs, inst);
+}
+}
+
+static void compoundassign (LexState *ls, struct LHS_assign *lh, int tk) {
+  expdesc e, r = lh->v;
+  BinOpr opr = getcompoundbinopr(tk);
+  check_condition(ls, vkisvar(lh->v.k), "syntax error");
+  check_readonly(ls, &lh->v);
+    checknext(ls, tk);
+enterlevel(ls);
+dupifneeded(ls, &lh->v, &r);
+  luaK_infix(ls->fs, opr, &r);
+    expr(ls, &e);
+    luaK_posfix(ls->fs, opr, &r, &e, ls->linenumber);
+leavelevel(ls);
+      luaK_storevar(ls->fs, &lh->v, &r);
+}
+
 
 static int cond (LexState *ls) {
   /* cond -> exp */
@@ -1801,6 +1850,10 @@ static void exprstat (LexState *ls) {
     v.prev = NULL;
     restassign(ls, &v, 1);
   }
+  else if (ls->t.token >= TK_COMPOUND_FIRST && ls->t.token <= TK_COMPOUND_LAST) { /* stat -> compound assignment ? */
+    v.prev = NULL;
+    compoundassign(ls, &v, ls->t.token);
+  }
   else {  /* stat -> func */
     Instruction *inst;
     check_condition(ls, v.v.k == VCALL, "syntax error");
diff --git a/star-expand.patch b/star-expand.patch
deleted file mode 100644
index 0a314fd..0000000
--- a/star-expand.patch
+++ /dev/null
@@ -1,176 +0,0 @@
-diff --git a/readme.md b/readme.md
-index 760cb2d..af8bfc9 100644
---- a/readme.md
-+++ b/readme.md
-@@ -19,6 +19,8 @@ Applying a patch is very easy:
- ### Compound operators
- Branch: compound-operators
- 
-+Download [compound-operators.patch] 
-+
- This patch adds the popular compound operators so well known and beloved in most other languages, that lua doesn't include by default.
- 
- - Add `+=, -=, *=, /=, //=, %=, ^=, |=, &=, <<=, >>=, ..=`
-@@ -41,6 +43,8 @@ print(t.u.v) -- 500
- ### Lambdas
- Branch: lambdas
- 
-+Download [lambdas.patch] ( 4 files changed, 89 insertions(+), 12 deletions(-))
-+
- This patch adds the support for shorter function syntax as known as lambdas, as it exists in other languages such as JavaScript, Java and Python.
- JavaScript's syntax with `=>` has been retained.
- 
-@@ -67,6 +71,8 @@ printcall( (a, b) => (b, a), 'one', 'two') -- two one
- ## Table extraction in local variables
- Branch: table-extract
- 
-+Download [table-extract.patch] ( 3 files changed, 39 insertions(+), 1 deletion(-))
-+
- This patch brings a little syntax suggar to extract multiple table fields into local variables at once.
- 
- - Add the syntax `local a, b, ... in expr `
-@@ -80,6 +86,8 @@ print(log(64, 2), floor(17.25), cos(0)) -- 6.0 17 1.0
- ### Syntax suggar for defining methods in tables
- Branch: methods-in-tables
- 
-+Download [methods-in-tables.patch] ( 2 files changed, 45 insertions(+), 3 deletions(-))
-+
- This patch brings a little syntax suggar to define methods in tables.
- 
- - Add method syntax in table (see below)
-@@ -110,6 +118,8 @@ print(mybank.balance) -- 1000
- ### Better numbers
- Branch: better-numbers
- 
-+Download [better-numbers.patch] ( 3 files changed, 29 insertions(+), 4 deletions(-))
-+
- This simple patch allows binary literals with 0b and thousend separators in  literals for better readability.
- 
- - Add underscore `_` thousend separator syntax in the code, e.g. `1_234_567` inspired by Java and JavaScript
-@@ -126,6 +136,8 @@ print(a+b) 1234575
- ### Default type metatable
- Branch: default-type-mt
- 
-+Download [default-type-mt.patch] ( 4 files changed, 66 insertions(+), 1 deletion(-))
-+
- You can call functions of the string table as methods without the need to do anything, because the type string has a shared metatable allowing it.
- Why don't tables do the same and allow to call table.insert, table.remove, table.sort, etc. as methods as well ?
- 
-@@ -150,6 +162,8 @@ print(t:concat(';')) -- 1;2;3;4;5
- ### Stared expand in table constructor
- Branch: star-expand
- 
-+Download [star-expand.patch] ( 4 files changed, 33 insertions(+), 9 deletions(-))
-+
- Well known by pythonists, this patch brings the unary `*` operator to lua, but it works only in table constructor to expand multiple arguments returned by a function. It's far from what Python allows, but better than nothing.
- 
- ```lua
-diff --git a/src/lcode.c b/src/lcode.c
-index 8761614..f7b288f 100644
---- a/src/lcode.c
-+++ b/src/lcode.c
-@@ -1811,6 +1811,7 @@ void luaK_setlist (FuncState *fs, int base, int nelems, int tostore) {
-   lua_assert(tostore != 0 && tostore <= LFIELDS_PER_FLUSH);
-   if (tostore == LUA_MULTRET)
-     tostore = 0;
-+    nelems++;
-   if (nelems <= MAXARG_C)
-     luaK_codeABC(fs, OP_SETLIST, base, tostore, nelems);
-   else {
-diff --git a/src/lparser.c b/src/lparser.c
-index 2b888c7..ac37424 100644
---- a/src/lparser.c
-+++ b/src/lparser.c
-@@ -841,6 +841,7 @@ typedef struct ConsControl {
-   int nh;  /* total number of 'record' elements */
-   int na;  /* number of array elements already stored */
-   int tostore;  /* number of array elements pending to be stored */
-+  int naundef; /* non-zero if exact number of elements not known */
- } ConsControl;
- 
- 
-@@ -870,7 +871,7 @@ static void closelistfield (FuncState *fs, ConsControl *cc) {
-   luaK_exp2nextreg(fs, &cc->v);
-   cc->v.k = VVOID;
-   if (cc->tostore == LFIELDS_PER_FLUSH) {
--    luaK_setlist(fs, cc->t->u.info, cc->na, cc->tostore);  /* flush */
-+    luaK_setlist(fs, cc->t->u.info, cc->naundef? LUA_MULTRET  : cc->na, cc->tostore);  /* flush */
-     cc->na += cc->tostore;
-     cc->tostore = 0;  /* no more items pending */
-   }
-@@ -881,15 +882,16 @@ static void lastlistfield (FuncState *fs, ConsControl *cc) {
-   if (cc->tostore == 0) return;
-   if (hasmultret(cc->v.k)) {
-     luaK_setmultret(fs, &cc->v);
--    luaK_setlist(fs, cc->t->u.info, cc->na, LUA_MULTRET);
-+    luaK_setlist(fs, cc->t->u.info, cc->naundef? LUA_MULTRET : cc->na, LUA_MULTRET);
-     cc->na--;  /* do not count last expression (unknown number of elements) */
-   }
-   else {
-     if (cc->v.k != VVOID)
-       luaK_exp2nextreg(fs, &cc->v);
--    luaK_setlist(fs, cc->t->u.info, cc->na, cc->tostore);
-+    luaK_setlist(fs, cc->t->u.info, cc->naundef? LUA_MULTRET : cc->na, cc->tostore);
-   }
-   cc->na += cc->tostore;
-+  cc->tostore = 0;
- }
- 
- 
-@@ -928,9 +930,10 @@ static void constructor (LexState *ls, expdesc *t) {
-   FuncState *fs = ls->fs;
-   int line = ls->linenumber;
-   int pc = luaK_codeABC(fs, OP_NEWTABLE, 0, 0, 0);
-+int doflush = 0;
-   ConsControl cc;
-   luaK_code(fs, 0);  /* space for extra arg. */
--  cc.na = cc.nh = cc.tostore = 0;
-+  cc.na = cc.nh = cc.tostore = cc.naundef = 0;
-   cc.t = t;
-   init_exp(t, VNONRELOC, fs->freereg);  /* table will be at stack top */
-   luaK_reserveregs(fs, 1);
-@@ -939,9 +942,14 @@ static void constructor (LexState *ls, expdesc *t) {
-   do {
-     lua_assert(cc.v.k == VVOID || cc.tostore > 0);
-     if (ls->t.token == '}') break;
--    closelistfield(fs, &cc);
-+    if (doflush && cc.tostore>0 && hasmultret(cc.v.k)) {
-+      lastlistfield(fs, &cc);
-+      cc.naundef=1;
-+    }
-+    else closelistfield(fs, &cc);
-+    doflush = testnext(ls, '*');
-     field(ls, &cc);
--  } while (testnext(ls, ',') || testnext(ls, ';'));
-+  } while (testnext(ls, ',') || testnext(ls, ';') );
-   check_match(ls, '}', '{', line);
-   lastlistfield(fs, &cc);
-   luaK_settablesize(fs, pc, t->u.info, cc.na, cc.nh);
-diff --git a/src/lvm.c b/src/lvm.c
-index fcd24e1..c59e534 100644
---- a/src/lvm.c
-+++ b/src/lvm.c
-@@ -1847,6 +1847,8 @@ void luaV_execute (lua_State *L, CallInfo *ci) {
-         int n = GETARG_B(i);
-         unsigned int last = GETARG_C(i);
-         Table *h = hvalue(s2v(ra));
-+        if (last == 0)
-+          last = luaH_getn(h) + 1;
-         if (n == 0)
-           n = cast_int(L->top.p - ra) - 1;  /* get up to the top */
-         else
-@@ -1856,12 +1858,11 @@ void luaV_execute (lua_State *L, CallInfo *ci) {
-           last += GETARG_Ax(*pc) * (MAXARG_C + 1);
-           pc++;
-         }
--        if (last > luaH_realasize(h))  /* needs more space? */
-+        if (--last > luaH_realasize(h))  /* needs more space? */
-           luaH_resizearray(L, h, last);  /* preallocate it at once */
-         for (; n > 0; n--) {
-           TValue *val = s2v(ra + n);
--          setobj2t(L, &h->array[last - 1], val);
--          last--;
-+          setobj2t(L, &h->array[--last], val);
-           luaC_barrierback(L, obj2gco(h), val);
-         }
-         vmbreak;
diff --git a/table-extract.patch b/table-extract.patch
deleted file mode 100644
index 24dfc93..0000000
--- a/table-extract.patch
+++ /dev/null
@@ -1,122 +0,0 @@
-diff --git a/readme.md b/readme.md
-index 760cb2d..af8bfc9 100644
---- a/readme.md
-+++ b/readme.md
-@@ -19,6 +19,8 @@ Applying a patch is very easy:
- ### Compound operators
- Branch: compound-operators
- 
-+Download [compound-operators.patch] 
-+
- This patch adds the popular compound operators so well known and beloved in most other languages, that lua doesn't include by default.
- 
- - Add `+=, -=, *=, /=, //=, %=, ^=, |=, &=, <<=, >>=, ..=`
-@@ -41,6 +43,8 @@ print(t.u.v) -- 500
- ### Lambdas
- Branch: lambdas
- 
-+Download [lambdas.patch] ( 4 files changed, 89 insertions(+), 12 deletions(-))
-+
- This patch adds the support for shorter function syntax as known as lambdas, as it exists in other languages such as JavaScript, Java and Python.
- JavaScript's syntax with `=>` has been retained.
- 
-@@ -67,6 +71,8 @@ printcall( (a, b) => (b, a), 'one', 'two') -- two one
- ## Table extraction in local variables
- Branch: table-extract
- 
-+Download [table-extract.patch] ( 3 files changed, 39 insertions(+), 1 deletion(-))
-+
- This patch brings a little syntax suggar to extract multiple table fields into local variables at once.
- 
- - Add the syntax `local a, b, ... in expr `
-@@ -80,6 +86,8 @@ print(log(64, 2), floor(17.25), cos(0)) -- 6.0 17 1.0
- ### Syntax suggar for defining methods in tables
- Branch: methods-in-tables
- 
-+Download [methods-in-tables.patch] ( 2 files changed, 45 insertions(+), 3 deletions(-))
-+
- This patch brings a little syntax suggar to define methods in tables.
- 
- - Add method syntax in table (see below)
-@@ -110,6 +118,8 @@ print(mybank.balance) -- 1000
- ### Better numbers
- Branch: better-numbers
- 
-+Download [better-numbers.patch] ( 3 files changed, 29 insertions(+), 4 deletions(-))
-+
- This simple patch allows binary literals with 0b and thousend separators in  literals for better readability.
- 
- - Add underscore `_` thousend separator syntax in the code, e.g. `1_234_567` inspired by Java and JavaScript
-@@ -126,6 +136,8 @@ print(a+b) 1234575
- ### Default type metatable
- Branch: default-type-mt
- 
-+Download [default-type-mt.patch] ( 4 files changed, 66 insertions(+), 1 deletion(-))
-+
- You can call functions of the string table as methods without the need to do anything, because the type string has a shared metatable allowing it.
- Why don't tables do the same and allow to call table.insert, table.remove, table.sort, etc. as methods as well ?
- 
-@@ -150,6 +162,8 @@ print(t:concat(';')) -- 1;2;3;4;5
- ### Stared expand in table constructor
- Branch: star-expand
- 
-+Download [star-expand.patch] ( 4 files changed, 33 insertions(+), 9 deletions(-))
-+
- Well known by pythonists, this patch brings the unary `*` operator to lua, but it works only in table constructor to expand multiple arguments returned by a function. It's far from what Python allows, but better than nothing.
- 
- ```lua
-diff --git a/src/lcode.c b/src/lcode.c
-index 8761614..d73b7fe 100644
---- a/src/lcode.c
-+++ b/src/lcode.c
-@@ -996,7 +996,7 @@ void luaK_exp2val (FuncState *fs, expdesc *e) {
- ** Try to make 'e' a K expression with an index in the range of R/K
- ** indices. Return true iff succeeded.
- */
--static int luaK_exp2K (FuncState *fs, expdesc *e) {
-+/*static*/ int luaK_exp2K (FuncState *fs, expdesc *e) {
-   if (!hasjumps(e)) {
-     int info;
-     switch (e->k) {  /* move constants to 'k' */
-diff --git a/src/lparser.c b/src/lparser.c
-index 2b888c7..97f1008 100644
---- a/src/lparser.c
-+++ b/src/lparser.c
-@@ -1722,6 +1722,26 @@ static void checktoclose (FuncState *fs, int level) {
-   }
- }
- 
-+static void extractlocal (LexState* ls, int nvars) {
-+FuncState* fs = ls->fs;
-+expdesc e, v;
-+  Vardesc *var;
-+int firstvar = fs->nactvar;
-+      luaK_nil(fs, fs->freereg, nvars);
-+    adjustlocalvars(ls, nvars);
-+  luaK_checkstack(fs, 1);
-+fs->freereg += nvars;
-+expr(ls, &e);
-+fs->freereg -= nvars;
-+init_exp(&v, VLOCAL, firstvar + nvars);
-+luaK_storevar(fs, &v, &e);
-+for (int i=0; i<nvars; i++) {
-+  var = getlocalvardesc(fs, firstvar+i);
-+codestring(&e, var->vd.name);
-+luaK_exp2K(fs, &e);
-+luaK_codeABC(fs, OP_GETFIELD, var->vd.ridx, firstvar + nvars, e.u.info);
-+}
-+}
- 
- static void localstat (LexState *ls) {
-   /* stat -> LOCAL NAME ATTRIB { ',' NAME ATTRIB } ['=' explist] */
-@@ -1745,6 +1765,10 @@ static void localstat (LexState *ls) {
-   } while (testnext(ls, ','));
-   if (testnext(ls, '='))
-     nexps = explist(ls, &e);
-+  else if (testnext(ls, TK_IN)) {
-+extractlocal(ls, nvars);
-+return;
-+  }
-   else {
-     e.k = VVOID;
-     nexps = 0;
