diff --git a/readme.md b/readme.md
index 760cb2d..af8bfc9 100644
--- a/readme.md
+++ b/readme.md
@@ -19,6 +19,8 @@ Applying a patch is very easy:
 ### Compound operators
 Branch: compound-operators
 
+Download [compound-operators.patch] 
+
 This patch adds the popular compound operators so well known and beloved in most other languages, that lua doesn't include by default.
 
 - Add `+=, -=, *=, /=, //=, %=, ^=, |=, &=, <<=, >>=, ..=`
@@ -41,6 +43,8 @@ print(t.u.v) -- 500
 ### Lambdas
 Branch: lambdas
 
+Download [lambdas.patch] ( 4 files changed, 89 insertions(+), 12 deletions(-))
+
 This patch adds the support for shorter function syntax as known as lambdas, as it exists in other languages such as JavaScript, Java and Python.
 JavaScript's syntax with `=>` has been retained.
 
@@ -67,6 +71,8 @@ printcall( (a, b) => (b, a), 'one', 'two') -- two one
 ## Table extraction in local variables
 Branch: table-extract
 
+Download [table-extract.patch] ( 3 files changed, 39 insertions(+), 1 deletion(-))
+
 This patch brings a little syntax suggar to extract multiple table fields into local variables at once.
 
 - Add the syntax `local a, b, ... in expr `
@@ -80,6 +86,8 @@ print(log(64, 2), floor(17.25), cos(0)) -- 6.0 17 1.0
 ### Syntax suggar for defining methods in tables
 Branch: methods-in-tables
 
+Download [methods-in-tables.patch] ( 2 files changed, 45 insertions(+), 3 deletions(-))
+
 This patch brings a little syntax suggar to define methods in tables.
 
 - Add method syntax in table (see below)
@@ -110,6 +118,8 @@ print(mybank.balance) -- 1000
 ### Better numbers
 Branch: better-numbers
 
+Download [better-numbers.patch] ( 3 files changed, 29 insertions(+), 4 deletions(-))
+
 This simple patch allows binary literals with 0b and thousend separators in  literals for better readability.
 
 - Add underscore `_` thousend separator syntax in the code, e.g. `1_234_567` inspired by Java and JavaScript
@@ -126,6 +136,8 @@ print(a+b) 1234575
 ### Default type metatable
 Branch: default-type-mt
 
+Download [default-type-mt.patch] ( 4 files changed, 66 insertions(+), 1 deletion(-))
+
 You can call functions of the string table as methods without the need to do anything, because the type string has a shared metatable allowing it.
 Why don't tables do the same and allow to call table.insert, table.remove, table.sort, etc. as methods as well ?
 
@@ -150,6 +162,8 @@ print(t:concat(';')) -- 1;2;3;4;5
 ### Stared expand in table constructor
 Branch: star-expand
 
+Download [star-expand.patch] ( 4 files changed, 33 insertions(+), 9 deletions(-))
+
 Well known by pythonists, this patch brings the unary `*` operator to lua, but it works only in table constructor to expand multiple arguments returned by a function. It's far from what Python allows, but better than nothing.
 
 ```lua
diff --git a/src/llex.c b/src/llex.c
index 5fc39a5..2c59df0 100644
--- a/src/llex.c
+++ b/src/llex.c
@@ -43,7 +43,10 @@ static const char *const luaX_tokens [] = {
     "in", "local", "nil", "not", "or", "repeat",
     "return", "then", "true", "until", "while",
     "//", "..", "...", "==", ">=", "<=", "~=",
-    "<<", ">>", "::", "<eof>",
+    "<<", ">>",
+    "+=", "-=", "*=", "/=", "//=", "%=", "^=", "..=",
+    "|=", "&=", "~=", "<<=", ">>=", "||=", "&&=",
+    "::", "<eof>",
     "<number>", "<integer>", "<name>", "<string>"
 };
 
@@ -456,7 +459,10 @@ static int llex (LexState *ls, SemInfo *seminfo) {
       }
       case '-': {  /* '-' or '--' (comment) */
         next(ls);
-        if (ls->current != '-') return '-';
+        if (ls->current != '-') {
+        if (check_next1(ls, '=')) return TK_SUBAS;  /* '-=' */
+        else return '-';
+}
         /* else is a comment */
         next(ls);
         if (ls->current == '[') {  /* long comment? */
@@ -491,31 +497,84 @@ static int llex (LexState *ls, SemInfo *seminfo) {
       case '<': {
         next(ls);
         if (check_next1(ls, '=')) return TK_LE;  /* '<=' */
-        else if (check_next1(ls, '<')) return TK_SHL;  /* '<<' */
+        else if (check_next1(ls, '<')) {
+if (check_next1(ls, '=')) return TK_SHLAS; /* '<<=' */
+else return TK_SHL;  /* '<<' */
+}
         else return '<';
       }
       case '>': {
         next(ls);
         if (check_next1(ls, '=')) return TK_GE;  /* '>=' */
-        else if (check_next1(ls, '>')) return TK_SHR;  /* '>>' */
+        else if (check_next1(ls, '>')) {
+if (check_next1(ls, '=')) return TK_SHRAS; /* '>>=' */
+else return TK_SHR;  /* '>>' */
+}
         else return '>';
       }
       case '/': {
         next(ls);
-        if (check_next1(ls, '/')) return TK_IDIV;  /* '//' */
-        else return '/';
+        if (check_next1(ls, '/')) {
+if (check_next1(ls, '=')) return TK_IDIVAS; /* '//=' */
+else return TK_IDIV;  /* '//' */
+}
+        else if (check_next1(ls, '=')) return TK_DIVAS; /* '/=' */
+else return '/';
       }
       case '~': {
         next(ls);
         if (check_next1(ls, '=')) return TK_NE;  /* '~=' */
         else return '~';
       }
+      case '!': {
+        next(ls);
+        if (check_next1(ls, '=')) return TK_NE;  /* '!=' */
+        else return TK_NOT;
+      }
+      case '&': {
+        next(ls);
+        if (check_next1(ls, '&')) {
+if (check_next1(ls, '=')) return TK_ANDAS; /* '&&=' */
+else return TK_AND;  /* '&&' */
+}
+else if (check_next1(ls, '=')) return TK_BANDAS; /* '&=' */
+        else return '&';
+      }
+      case '|': {
+        next(ls);
+        if (check_next1(ls, '|')) {
+if (check_next1(ls, '=')) return TK_ORAS; /* '||=' */
+else return TK_OR;  /* '||' */
+}
+else if (check_next1(ls, '=')) return TK_BORAS; /* '|=' */
+        else return '|';
+      }
+      case '+': {
+        next(ls);
+        if (check_next1(ls, '=')) return TK_ADDAS;  /* '+=' */
+        else return '+';
+      }
+      case '*': {
+        next(ls);
+        if (check_next1(ls, '=')) return TK_MULAS;  /* '*=' */
+        else return '*';
+      }
+      case '%': {
+        next(ls);
+        if (check_next1(ls, '=')) return TK_MODAS;  /* '%=' */
+        else return '%';
+      }
+      case '^': {
+        next(ls);
+        if (check_next1(ls, '=')) return TK_POWAS;  /* '^=' */
+        else return '^';
+      }
       case ':': {
         next(ls);
         if (check_next1(ls, ':')) return TK_DBCOLON;  /* '::' */
         else return ':';
       }
-      case '"': case '\'': {  /* short literal strings */
+      case '"': case '\'': case '`': {  /* short literal strings */
         read_string(ls, ls->current, seminfo);
         return TK_STRING;
       }
@@ -524,6 +583,7 @@ static int llex (LexState *ls, SemInfo *seminfo) {
         if (check_next1(ls, '.')) {
           if (check_next1(ls, '.'))
             return TK_DOTS;   /* '...' */
+else if (check_next1(ls, '=')) return TK_CONCATAS; /* '..=' */
           else return TK_CONCAT;   /* '..' */
         }
         else if (!lisdigit(ls->current)) return '.';
diff --git a/src/llex.h b/src/llex.h
index 389d2f8..df2cba9 100644
--- a/src/llex.h
+++ b/src/llex.h
@@ -38,6 +38,8 @@ enum RESERVED {
   /* other terminal symbols */
   TK_IDIV, TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE,
   TK_SHL, TK_SHR,
+  TK_COMPOUND_FIRST, TK_ADDAS=TK_COMPOUND_FIRST, TK_SUBAS, TK_MULAS, TK_DIVAS, TK_IDIVAS, TK_MODAS, TK_POWAS, TK_CONCATAS,
+  TK_BORAS, TK_BANDAS, TK_BXORAS, TK_SHLAS, TK_SHRAS, TK_ORAS, TK_ANDAS, TK_COMPOUND_LAST=TK_ANDAS,
   TK_DBCOLON, TK_EOS,
   TK_FLT, TK_INT, TK_NAME, TK_STRING
 };
diff --git a/src/lparser.c b/src/lparser.c
index 2b888c7..e9946cc 100644
--- a/src/lparser.c
+++ b/src/lparser.c
@@ -1402,6 +1402,55 @@ static void restassign (LexState *ls, struct LHS_assign *lh, int nvars) {
   luaK_storevar(ls->fs, &lh->v, &e);
 }
 
+static BinOpr getcompoundbinopr (int op) {
+  switch (op) {
+    case TK_ADDAS: return OPR_ADD;
+    case TK_SUBAS: return OPR_SUB;
+    case TK_MULAS: return OPR_MUL;
+    case TK_MODAS: return OPR_MOD;
+    case TK_POWAS: return OPR_POW;
+    case TK_DIVAS: return OPR_DIV;
+    case TK_IDIVAS: return OPR_IDIV;
+    case TK_BANDAS: return OPR_BAND;
+    case TK_BORAS: return OPR_BOR;
+    case TK_BXORAS: return OPR_BXOR;
+    case TK_SHLAS: return OPR_SHL;
+    case TK_SHRAS: return OPR_SHR;
+    case TK_CONCATAS: return OPR_CONCAT;
+    case TK_ANDAS: return OPR_AND;
+    case TK_ORAS: return OPR_OR;
+    default: return OPR_NOBINOPR;
+  }
+}
+
+
+static void dupifneeded (LexState* ls, expdesc* src, expdesc* dst) {
+int i = ls->fs->pc;
+Instruction inst = i>0? ls->fs->f->code[i -1] :0;
+int regdst, op = GET_OPCODE(inst);
+if (i>0 && op>=OP_GETTABUP  && op<=OP_GETFIELD) {
+  regdst = ls->fs->freereg; 
+luaK_reserveregs(ls->fs, 1);
+inst = SETARG_A(inst, regdst);
+luaK_code(ls->fs, inst);
+}
+}
+
+static void compoundassign (LexState *ls, struct LHS_assign *lh, int tk) {
+  expdesc e, r = lh->v;
+  BinOpr opr = getcompoundbinopr(tk);
+  check_condition(ls, vkisvar(lh->v.k), "syntax error");
+  check_readonly(ls, &lh->v);
+    checknext(ls, tk);
+enterlevel(ls);
+dupifneeded(ls, &lh->v, &r);
+  luaK_infix(ls->fs, opr, &r);
+    expr(ls, &e);
+    luaK_posfix(ls->fs, opr, &r, &e, ls->linenumber);
+leavelevel(ls);
+      luaK_storevar(ls->fs, &lh->v, &r);
+}
+
 
 static int cond (LexState *ls) {
   /* cond -> exp */
@@ -1801,6 +1850,10 @@ static void exprstat (LexState *ls) {
     v.prev = NULL;
     restassign(ls, &v, 1);
   }
+  else if (ls->t.token >= TK_COMPOUND_FIRST && ls->t.token <= TK_COMPOUND_LAST) { /* stat -> compound assignment ? */
+    v.prev = NULL;
+    compoundassign(ls, &v, ls->t.token);
+  }
   else {  /* stat -> func */
     Instruction *inst;
     check_condition(ls, v.v.k == VCALL, "syntax error");
