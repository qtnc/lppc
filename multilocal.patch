diff --git a/better-numbers.patch b/better-numbers.patch
deleted file mode 100644
index c4c18ed..0000000
--- a/better-numbers.patch
+++ /dev/null
@@ -1,49 +0,0 @@
-diff --git a/src/llex.c b/src/llex.c
-index 5fc39a5..4224d8e 100644
---- a/src/llex.c
-+++ b/src/llex.c
-@@ -235,11 +235,11 @@ static int read_numeral (LexState *ls, SemInfo *seminfo) {
-   for (;;) {
-     if (check_next2(ls, expo))  /* exponent mark? */
-       check_next2(ls, "-+");  /* optional exponent sign */
--    else if (lisxdigit(ls->current) || ls->current == '.')  /* '%x|%.' */
-+    else if (lisxdigit(ls->current) || ls->current == '.' || ls->current == '_')  /* '%x|%.' */
-       save_and_next(ls);
-     else break;
-   }
--  if (lislalpha(ls->current))  /* is numeral touching a letter? */
-+  if (lislalpha(ls->current) && ls->current != '_')  /* is numeral touching a letter? */
-     save_and_next(ls);  /* force an error */
-   save(ls, '\0');
-   if (luaO_str2num(luaZ_buffer(ls->buff), &obj) == 0)  /* format error? */
-diff --git a/src/lobject.c b/src/lobject.c
-index 9cfa522..68be38b 100644
---- a/src/lobject.c
-+++ b/src/lobject.c
-@@ -282,13 +282,24 @@ static const char *l_str2int (const char *s, lua_Integer *result) {
-   if (s[0] == '0' &&
-       (s[1] == 'x' || s[1] == 'X')) {  /* hex? */
-     s += 2;  /* skip '0x' */
--    for (; lisxdigit(cast_uchar(*s)); s++) {
-+    for (; lisxdigit(cast_uchar(*s)) || *s == '_'; s++) {
-+      if (*s == '_') continue;
-       a = a * 16 + luaO_hexavalue(*s);
-       empty = 0;
-     }
-   }
-+  else if (s[0] == '0' &&
-+      (s[1] == 'b' || s[1] == 'B')) {  /* binary? */
-+    s += 2;  /* skip '0x' */
-+    for (; *s == '0' || *s == '1' || *s == '_'; s++) {
-+      if (*s == '_') continue;
-+      a = a * 2 + (*s - '0');
-+      empty = 0;
-+    }
-+  }
-   else {  /* decimal */
--    for (; lisdigit(cast_uchar(*s)); s++) {
-+    for (; lisdigit(cast_uchar(*s)) || *s=='_'; s++) {
-+      if (*s == '_') continue;
-       int d = *s - '0';
-       if (a >= MAXBY10 && (a > MAXBY10 || d > MAXLASTD + neg))  /* overflow? */
-         return NULL;  /* do not accept it (as integer) */
diff --git a/better-strings.patch b/better-strings.patch
deleted file mode 100644
index aa0b678..0000000
--- a/better-strings.patch
+++ /dev/null
@@ -1,57 +0,0 @@
-diff --git a/src/lctype.c b/src/lctype.c
-index 9542280..812a938 100644
---- a/src/lctype.c
-+++ b/src/lctype.c
-@@ -17,6 +17,7 @@
- #include <limits.h>
- 
- 
-+#define LUA_UCID 1
- #if defined (LUA_UCID)		/* accept UniCode IDentifiers? */
- /* consider all non-ascii codepoints to be alphabetic */
- #define NONA		0x01
-diff --git a/src/llex.c b/src/llex.c
-index 5fc39a5..bb66478 100644
---- a/src/llex.c
-+++ b/src/llex.c
-@@ -388,14 +388,16 @@ static void read_string (LexState *ls, int del, SemInfo *seminfo) {
-         break;  /* to avoid warnings */
-       case '\n':
-       case '\r':
--        lexerror(ls, "unfinished string", TK_STRING);
--        break;  /* to avoid warnings */
-+inclinenumber(ls);
-+        save(ls, '\n');
-+        break;
-       case '\\': {  /* escape sequences */
-         int c;  /* final character to be saved */
-         save_and_next(ls);  /* keep '\\' for error messages */
-         switch (ls->current) {
-           case 'a': c = '\a'; goto read_save;
-           case 'b': c = '\b'; goto read_save;
-+          case 'e': c = '\x1b'; goto read_save;
-           case 'f': c = '\f'; goto read_save;
-           case 'n': c = '\n'; goto read_save;
-           case 'r': c = '\r'; goto read_save;
-@@ -404,8 +406,10 @@ static void read_string (LexState *ls, int del, SemInfo *seminfo) {
-           case 'x': c = readhexaesc(ls); goto read_save;
-           case 'u': utf8esc(ls);  goto no_save;
-           case '\n': case '\r':
--            inclinenumber(ls); c = '\n'; goto only_save;
--          case '\\': case '\"': case '\'':
-+            inclinenumber(ls);          
-+            luaZ_buffremove(ls->buff, 1);  /* remove '\\' */
-+            goto no_save;
-+          case '\\': case '\"': case '\'': case '`':
-             c = ls->current; goto read_save;
-           case EOZ: goto no_save;  /* will raise an error next loop */
-           case 'z': {  /* zap following span of spaces */
-@@ -515,7 +519,7 @@ static int llex (LexState *ls, SemInfo *seminfo) {
-         if (check_next1(ls, ':')) return TK_DBCOLON;  /* '::' */
-         else return ':';
-       }
--      case '"': case '\'': {  /* short literal strings */
-+      case '"': case '\'': case '`': {  /* short literal strings */
-         read_string(ls, ls->current, seminfo);
-         return TK_STRING;
-       }
diff --git a/compound-operators.patch b/compound-operators.patch
deleted file mode 100644
index ebeaee1..0000000
--- a/compound-operators.patch
+++ /dev/null
@@ -1,210 +0,0 @@
-diff --git a/src/llex.c b/src/llex.c
-index 5fc39a5..2c59df0 100644
---- a/src/llex.c
-+++ b/src/llex.c
-@@ -43,7 +43,10 @@ static const char *const luaX_tokens [] = {
-     "in", "local", "nil", "not", "or", "repeat",
-     "return", "then", "true", "until", "while",
-     "//", "..", "...", "==", ">=", "<=", "~=",
--    "<<", ">>", "::", "<eof>",
-+    "<<", ">>",
-+    "+=", "-=", "*=", "/=", "//=", "%=", "^=", "..=",
-+    "|=", "&=", "~=", "<<=", ">>=", "||=", "&&=",
-+    "::", "<eof>",
-     "<number>", "<integer>", "<name>", "<string>"
- };
- 
-@@ -456,7 +459,10 @@ static int llex (LexState *ls, SemInfo *seminfo) {
-       }
-       case '-': {  /* '-' or '--' (comment) */
-         next(ls);
--        if (ls->current != '-') return '-';
-+        if (ls->current != '-') {
-+        if (check_next1(ls, '=')) return TK_SUBAS;  /* '-=' */
-+        else return '-';
-+}
-         /* else is a comment */
-         next(ls);
-         if (ls->current == '[') {  /* long comment? */
-@@ -491,31 +497,84 @@ static int llex (LexState *ls, SemInfo *seminfo) {
-       case '<': {
-         next(ls);
-         if (check_next1(ls, '=')) return TK_LE;  /* '<=' */
--        else if (check_next1(ls, '<')) return TK_SHL;  /* '<<' */
-+        else if (check_next1(ls, '<')) {
-+if (check_next1(ls, '=')) return TK_SHLAS; /* '<<=' */
-+else return TK_SHL;  /* '<<' */
-+}
-         else return '<';
-       }
-       case '>': {
-         next(ls);
-         if (check_next1(ls, '=')) return TK_GE;  /* '>=' */
--        else if (check_next1(ls, '>')) return TK_SHR;  /* '>>' */
-+        else if (check_next1(ls, '>')) {
-+if (check_next1(ls, '=')) return TK_SHRAS; /* '>>=' */
-+else return TK_SHR;  /* '>>' */
-+}
-         else return '>';
-       }
-       case '/': {
-         next(ls);
--        if (check_next1(ls, '/')) return TK_IDIV;  /* '//' */
--        else return '/';
-+        if (check_next1(ls, '/')) {
-+if (check_next1(ls, '=')) return TK_IDIVAS; /* '//=' */
-+else return TK_IDIV;  /* '//' */
-+}
-+        else if (check_next1(ls, '=')) return TK_DIVAS; /* '/=' */
-+else return '/';
-       }
-       case '~': {
-         next(ls);
-         if (check_next1(ls, '=')) return TK_NE;  /* '~=' */
-         else return '~';
-       }
-+      case '!': {
-+        next(ls);
-+        if (check_next1(ls, '=')) return TK_NE;  /* '!=' */
-+        else return TK_NOT;
-+      }
-+      case '&': {
-+        next(ls);
-+        if (check_next1(ls, '&')) {
-+if (check_next1(ls, '=')) return TK_ANDAS; /* '&&=' */
-+else return TK_AND;  /* '&&' */
-+}
-+else if (check_next1(ls, '=')) return TK_BANDAS; /* '&=' */
-+        else return '&';
-+      }
-+      case '|': {
-+        next(ls);
-+        if (check_next1(ls, '|')) {
-+if (check_next1(ls, '=')) return TK_ORAS; /* '||=' */
-+else return TK_OR;  /* '||' */
-+}
-+else if (check_next1(ls, '=')) return TK_BORAS; /* '|=' */
-+        else return '|';
-+      }
-+      case '+': {
-+        next(ls);
-+        if (check_next1(ls, '=')) return TK_ADDAS;  /* '+=' */
-+        else return '+';
-+      }
-+      case '*': {
-+        next(ls);
-+        if (check_next1(ls, '=')) return TK_MULAS;  /* '*=' */
-+        else return '*';
-+      }
-+      case '%': {
-+        next(ls);
-+        if (check_next1(ls, '=')) return TK_MODAS;  /* '%=' */
-+        else return '%';
-+      }
-+      case '^': {
-+        next(ls);
-+        if (check_next1(ls, '=')) return TK_POWAS;  /* '^=' */
-+        else return '^';
-+      }
-       case ':': {
-         next(ls);
-         if (check_next1(ls, ':')) return TK_DBCOLON;  /* '::' */
-         else return ':';
-       }
--      case '"': case '\'': {  /* short literal strings */
-+      case '"': case '\'': case '`': {  /* short literal strings */
-         read_string(ls, ls->current, seminfo);
-         return TK_STRING;
-       }
-@@ -524,6 +583,7 @@ static int llex (LexState *ls, SemInfo *seminfo) {
-         if (check_next1(ls, '.')) {
-           if (check_next1(ls, '.'))
-             return TK_DOTS;   /* '...' */
-+else if (check_next1(ls, '=')) return TK_CONCATAS; /* '..=' */
-           else return TK_CONCAT;   /* '..' */
-         }
-         else if (!lisdigit(ls->current)) return '.';
-diff --git a/src/llex.h b/src/llex.h
-index 389d2f8..df2cba9 100644
---- a/src/llex.h
-+++ b/src/llex.h
-@@ -38,6 +38,8 @@ enum RESERVED {
-   /* other terminal symbols */
-   TK_IDIV, TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE,
-   TK_SHL, TK_SHR,
-+  TK_COMPOUND_FIRST, TK_ADDAS=TK_COMPOUND_FIRST, TK_SUBAS, TK_MULAS, TK_DIVAS, TK_IDIVAS, TK_MODAS, TK_POWAS, TK_CONCATAS,
-+  TK_BORAS, TK_BANDAS, TK_BXORAS, TK_SHLAS, TK_SHRAS, TK_ORAS, TK_ANDAS, TK_COMPOUND_LAST=TK_ANDAS,
-   TK_DBCOLON, TK_EOS,
-   TK_FLT, TK_INT, TK_NAME, TK_STRING
- };
-diff --git a/src/lparser.c b/src/lparser.c
-index 1ac8299..c609e26 100644
---- a/src/lparser.c
-+++ b/src/lparser.c
-@@ -1401,6 +1401,55 @@ static void restassign (LexState *ls, struct LHS_assign *lh, int nvars) {
-   luaK_storevar(ls->fs, &lh->v, &e);
- }
- 
-+static BinOpr getcompoundbinopr (int op) {
-+  switch (op) {
-+    case TK_ADDAS: return OPR_ADD;
-+    case TK_SUBAS: return OPR_SUB;
-+    case TK_MULAS: return OPR_MUL;
-+    case TK_MODAS: return OPR_MOD;
-+    case TK_POWAS: return OPR_POW;
-+    case TK_DIVAS: return OPR_DIV;
-+    case TK_IDIVAS: return OPR_IDIV;
-+    case TK_BANDAS: return OPR_BAND;
-+    case TK_BORAS: return OPR_BOR;
-+    case TK_BXORAS: return OPR_BXOR;
-+    case TK_SHLAS: return OPR_SHL;
-+    case TK_SHRAS: return OPR_SHR;
-+    case TK_CONCATAS: return OPR_CONCAT;
-+    case TK_ANDAS: return OPR_AND;
-+    case TK_ORAS: return OPR_OR;
-+    default: return OPR_NOBINOPR;
-+  }
-+}
-+
-+
-+static void dupifneeded (LexState* ls, expdesc* src, expdesc* dst) {
-+int i = ls->fs->pc;
-+Instruction inst = i>0? ls->fs->f->code[i -1] :0;
-+int regdst, op = GET_OPCODE(inst);
-+if (i>0 && op>=OP_GETTABUP  && op<=OP_GETFIELD) {
-+  regdst = ls->fs->freereg; 
-+luaK_reserveregs(ls->fs, 1);
-+inst = SETARG_A(inst, regdst);
-+luaK_code(ls->fs, inst);
-+}
-+}
-+
-+static void compoundassign (LexState *ls, struct LHS_assign *lh, int tk) {
-+  expdesc e, r = lh->v;
-+  BinOpr opr = getcompoundbinopr(tk);
-+  check_condition(ls, vkisvar(lh->v.k), "syntax error");
-+  check_readonly(ls, &lh->v);
-+    checknext(ls, tk);
-+enterlevel(ls);
-+dupifneeded(ls, &lh->v, &r);
-+  luaK_infix(ls->fs, opr, &r);
-+    expr(ls, &e);
-+    luaK_posfix(ls->fs, opr, &r, &e, ls->linenumber);
-+leavelevel(ls);
-+      luaK_storevar(ls->fs, &lh->v, &r);
-+}
-+
- 
- static int cond (LexState *ls) {
-   /* cond -> exp */
-@@ -1800,6 +1849,10 @@ static void exprstat (LexState *ls) {
-     v.prev = NULL;
-     restassign(ls, &v, 1);
-   }
-+  else if (ls->t.token >= TK_COMPOUND_FIRST && ls->t.token <= TK_COMPOUND_LAST) { /* stat -> compound assignment ? */
-+    v.prev = NULL;
-+    compoundassign(ls, &v, ls->t.token);
-+  }
-   else {  /* stat -> func */
-     Instruction *inst;
-     check_condition(ls, v.v.k == VCALL, "syntax error");
diff --git a/default-params.patch b/default-params.patch
deleted file mode 100644
index 8d82c96..0000000
--- a/default-params.patch
+++ /dev/null
@@ -1,80 +0,0 @@
-diff --git a/src/lparser.c b/src/lparser.c
-index 1ac8299..f39ba0f 100644
---- a/src/lparser.c
-+++ b/src/lparser.c
-@@ -952,9 +952,56 @@ static void constructor (LexState *ls, expdesc *t) {
- static void setvararg (FuncState *fs, int nparams) {
-   fs->f->is_vararg = 1;
-   luaK_codeABC(fs, OP_VARARGPREP, nparams, 0, 0);
-+  if (fs->pc>1) {
-+    Instruction inst = *(fs->f->code +fs->pc -1);
-+    memmove(fs->f->code+1, fs->f->code, sizeof(Instruction)* (fs->pc -1));
-+    *fs->f->code=inst;
-+  }
-+}
-+
-+static void pardefault (LexState* ls, int paridx, int regdelta) {
-+expdesc p, e;
-+int jf;
-+  init_exp(&p, VLOCAL, 0);
-+p.u.var.ridx = paridx;
-+luaK_code(ls->fs, CREATE_ABCk(OP_TEST, paridx, 0, 0, 1));
-+jf = luaK_code(ls->fs, CREATE_sJ(OP_JMP, OFFSET_sJ, 0));
-+ls->fs->freereg = regdelta;
-+expr(ls, &e);
-+      luaK_storevar(ls->fs, &p, &e);
-+ls->fs->freereg = 0;
-+SETARG_sJ(ls->fs->f->code[jf], ls->fs->pc -jf -1);
-+}
-+
-+static void patchpardefaults (FuncState* fs, int regdelta, int regstart) {
-+int x;
-+for (Instruction* inst = fs->f->code; inst<fs->f->code+fs->pc; inst++) {
-+#define OP(X) x = GETARG_##X(*inst); if (x>=regdelta) SETARG_##X(*inst, x-regdelta+regstart);
-+switch(GET_OPCODE(*inst)) {
-+case OP_GETTABLE: case OP_SETTABLE: case OP_SELF: case OP_ADD: case OP_SUB: case OP_MUL: case OP_DIV: case OP_IDIV: case OP_MOD: case OP_BAND: case OP_BOR: case OP_BXOR: case OP_SHR: case OP_SHL: case OP_POW:
-+OP(C) // fallthrough
-+case OP_MOVE: case OP_GETI: case OP_GETFIELD:
-+case OP_ADDI: case OP_ADDK: case OP_SUBK: case OP_MULK: case OP_DIVK: case OP_IDIVK: case OP_MODK: case OP_POWK: case OP_BANDK: case OP_BORK: case OP_BXORK: case OP_SHRI: case OP_SHLI:
-+case OP_MMBIN: case OP_UNM: case OP_NOT: case OP_BNOT: case OP_LEN:
-+case OP_EQ: case OP_LT: case OP_LE: case OP_TESTSET: 
-+OP(B) // fallthrough
-+case OP_LOADI: case OP_LOADF: case OP_LOADK: case OP_LOADKX: case OP_LOADFALSE: case OP_LFALSESKIP: case OP_LOADTRUE: case OP_LOADNIL: 
-+case OP_GETUPVAL: case OP_SETUPVAL: case OP_GETTABUP: case OP_SETTABUP: case OP_NEWTABLE: 
-+case OP_MMBINI: case OP_MMBINK: case OP_CONCAT: case OP_CLOSE: case OP_TBC: case OP_EQK: case OP_EQI: case OP_LTI: case OP_LEI: case OP_GTI: case OP_GEI: case OP_TEST: 
-+case OP_CALL: case OP_TAILCALL: case OP_RETURN: case OP_RETURN1: case OP_SETLIST:
-+OP(A)
-+break;
-+case OP_SETFIELD: case OP_SETI:
-+OP(A) OP(C)
-+break;
-+default:
-+break;
-+}
-+#undef OP
-+}
-+if (fs->f->maxstacksize>=regdelta) fs->f->maxstacksize-=regdelta;
- }
- 
--
- static void parlist (LexState *ls) {
-   /* parlist -> [ {NAME ','} (NAME | '...') ] */
-   FuncState *fs = ls->fs;
-@@ -966,6 +1013,8 @@ static void parlist (LexState *ls) {
-       switch (ls->t.token) {
-         case TK_NAME: {
-           new_localvar(ls, str_checkname(ls));
-+  adjustlocalvars(ls, 1);
-+if (testnext(ls, '=')) pardefault(ls, nparams, 128);
-           nparams++;
-           break;
-         }
-@@ -978,7 +1027,7 @@ static void parlist (LexState *ls) {
-       }
-     } while (!isvararg && testnext(ls, ','));
-   }
--  adjustlocalvars(ls, nparams);
-+  patchpardefaults(fs, 128, nparams);
-   f->numparams = cast_byte(fs->nactvar);
-   if (isvararg)
-     setvararg(fs, f->numparams);  /* declared vararg */
diff --git a/default-type-mt.patch b/default-type-mt.patch
deleted file mode 100644
index 2582c20..0000000
--- a/default-type-mt.patch
+++ /dev/null
@@ -1,107 +0,0 @@
-diff --git a/src/lapi.c b/src/lapi.c
-index 04e09cf..c3f98ab 100644
---- a/src/lapi.c
-+++ b/src/lapi.c
-@@ -798,6 +798,22 @@ LUA_API int lua_getmetatable (lua_State *L, int objindex) {
-   return res;
- }
- 
-+LUA_API int lua_gettypemetatable (lua_State *L, int type) {
-+  const TValue *obj;
-+  Table *mt;
-+  int res = 0;
-+  lua_lock(L);
-+  mt = G(L)->mt[type];
-+  if (mt != NULL) {
-+    sethvalue2s(L, L->top.p, mt);
-+    api_incr_top(L);
-+    res = 1;
-+  }
-+  lua_unlock(L);
-+  return res;
-+}
-+
-+
- 
- LUA_API int lua_getiuservalue (lua_State *L, int idx, int n) {
-   TValue *o;
-@@ -969,6 +985,22 @@ LUA_API int lua_setmetatable (lua_State *L, int objindex) {
-   return 1;
- }
- 
-+LUA_API int lua_settypemetatable (lua_State *L, int type) {
-+  Table *mt;
-+  lua_lock(L);
-+  api_checknelems(L, 1);
-+  if (ttisnil(s2v(L->top.p - 1)))
-+    mt = NULL;
-+  else {
-+    api_check(L, ttistable(s2v(L->top.p - 1)), "table expected");
-+    mt = hvalue(s2v(L->top.p - 1));
-+  }
-+  G(L)->mt[type] = mt;
-+  L->top.p--;
-+  lua_unlock(L);
-+  return 1;
-+}
-+
- 
- LUA_API int lua_setiuservalue (lua_State *L, int idx, int n) {
-   TValue *o;
-diff --git a/src/ldblib.c b/src/ldblib.c
-index 6dcbaa9..f1f3efd 100644
---- a/src/ldblib.c
-+++ b/src/ldblib.c
-@@ -61,6 +61,23 @@ static int db_setmetatable (lua_State *L) {
-   return 1;  /* return 1st argument */
- }
- 
-+static int db_gettypemetatable (lua_State *L) {
-+  luaL_checkany(L, 1);
-+  if (!lua_gettypemetatable(L, lua_type(L, 1))) {
-+    lua_pushnil(L);  /* no metatable */
-+  }
-+  return 1;
-+}
-+
-+
-+static int db_settypemetatable (lua_State *L) {
-+  int t = lua_type(L, 2);
-+  luaL_argexpected(L, t == LUA_TNIL || t == LUA_TTABLE, 2, "nil or table");
-+  lua_settop(L, 2);
-+  lua_settypemetatable(L, lua_type(L, 1));
-+  return 1;  /* return 1st argument */
-+}
-+
- 
- static int db_getuservalue (lua_State *L) {
-   int n = (int)luaL_optinteger(L, 2, 1);
-@@ -462,6 +479,7 @@ static const luaL_Reg dblib[] = {
-   {"getlocal", db_getlocal},
-   {"getregistry", db_getregistry},
-   {"getmetatable", db_getmetatable},
-+  {"gettypemetatable", db_gettypemetatable},
-   {"getupvalue", db_getupvalue},
-   {"upvaluejoin", db_upvaluejoin},
-   {"upvalueid", db_upvalueid},
-@@ -469,6 +487,7 @@ static const luaL_Reg dblib[] = {
-   {"sethook", db_sethook},
-   {"setlocal", db_setlocal},
-   {"setmetatable", db_setmetatable},
-+  {"settypemetatable", db_settypemetatable},
-   {"setupvalue", db_setupvalue},
-   {"traceback", db_traceback},
-   {"setcstacklimit", db_setcstacklimit},
-diff --git a/src/ltable.c b/src/ltable.c
-index 3353c04..d051c83 100644
---- a/src/ltable.c
-+++ b/src/ltable.c
-@@ -626,7 +626,7 @@ static void rehash (lua_State *L, Table *t, const TValue *ek) {
- Table *luaH_new (lua_State *L) {
-   GCObject *o = luaC_newobj(L, LUA_VTABLE, sizeof(Table));
-   Table *t = gco2t(o);
--  t->metatable = NULL;
-+  t->metatable = G(L)->mt[LUA_TTABLE];
-   t->flags = cast_byte(maskflags);  /* table has no metamethod fields */
-   t->array = NULL;
-   t->alimit = 0;
diff --git a/lambdas-ltgt.patch b/lambdas-ltgt.patch
deleted file mode 100644
index 29edb5d..0000000
--- a/lambdas-ltgt.patch
+++ /dev/null
@@ -1,77 +0,0 @@
-diff --git a/src/lparser.c b/src/lparser.c
-index 1ac8299..ecce900 100644
---- a/src/lparser.c
-+++ b/src/lparser.c
-@@ -955,13 +955,13 @@ static void setvararg (FuncState *fs, int nparams) {
- }
- 
- 
--static void parlist (LexState *ls) {
-+static void parlist_ext (LexState *ls, int end_token) {
-   /* parlist -> [ {NAME ','} (NAME | '...') ] */
-   FuncState *fs = ls->fs;
-   Proto *f = fs->f;
-   int nparams = 0;
-   int isvararg = 0;
--  if (ls->t.token != ')') {  /* is 'parlist' not empty? */
-+  if (ls->t.token != end_token) {  /* is 'parlist' not empty? */
-     do {
-       switch (ls->t.token) {
-         case TK_NAME: {
-@@ -985,6 +985,10 @@ static void parlist (LexState *ls) {
-   luaK_reserveregs(fs, fs->nactvar);  /* reserve registers for parameters */
- }
- 
-+static void parlist (LexState *ls) {
-+  parlist_ext(ls, ')');
-+}
-+
- 
- static void body (LexState *ls, expdesc *e, int ismethod, int line) {
-   /* body ->  '(' parlist ')' block END */
-@@ -1008,6 +1012,25 @@ static void body (LexState *ls, expdesc *e, int ismethod, int line) {
- }
- 
- 
-+static void simplebody (LexState *ls, expdesc *e, int line) {
-+  /* simplebody ->  parlist `>' expr */
-+  FuncState new_fs;
-+  expdesc ebody;
-+  int reg;
-+  BlockCnt bl;
-+  new_fs.f = addprototype(ls);
-+  new_fs.f->linedefined = line;
-+  open_func(ls, &new_fs, &bl);
-+  parlist_ext(ls, '>');
-+  checknext(ls, '>');
-+  expr(ls, &ebody);
-+  reg = luaK_exp2anyreg(&new_fs, &ebody);
-+  luaK_ret(&new_fs, reg, 1);
-+  new_fs.f->lastlinedefined = ls->linenumber;
-+  codeclosure(ls, e);
-+  close_func(ls);
-+}
-+
- static int explist (LexState *ls, expdesc *v) {
-   /* explist -> expr { ',' expr } */
-   int n = 1;  /* at least one expression */
-@@ -1135,7 +1158,6 @@ static void suffixedexp (LexState *ls, expdesc *v) {
-   }
- }
- 
--
- static void simpleexp (LexState *ls, expdesc *v) {
-   /* simpleexp -> FLT | INT | STRING | NIL | TRUE | FALSE | ... |
-                   constructor | FUNCTION body | suffixedexp */
-@@ -1182,6 +1204,11 @@ static void simpleexp (LexState *ls, expdesc *v) {
-       body(ls, v, 0, ls->linenumber);
-       return;
-     }
-+    case '<': {
-+      luaX_next(ls);
-+      simplebody(ls, v, ls->linenumber);
-+      return;
-+    }
-     default: {
-       suffixedexp(ls, v);
-       return;
diff --git a/lambdas-ruby.patch b/lambdas-ruby.patch
deleted file mode 100644
index fda0cda..0000000
--- a/lambdas-ruby.patch
+++ /dev/null
@@ -1,77 +0,0 @@
-diff --git a/src/lparser.c b/src/lparser.c
-index 1ac8299..7e4eacc 100644
---- a/src/lparser.c
-+++ b/src/lparser.c
-@@ -955,13 +955,13 @@ static void setvararg (FuncState *fs, int nparams) {
- }
- 
- 
--static void parlist (LexState *ls) {
-+static void parlist_ext (LexState *ls, int end_token) {
-   /* parlist -> [ {NAME ','} (NAME | '...') ] */
-   FuncState *fs = ls->fs;
-   Proto *f = fs->f;
-   int nparams = 0;
-   int isvararg = 0;
--  if (ls->t.token != ')') {  /* is 'parlist' not empty? */
-+  if (ls->t.token != end_token) {  /* is 'parlist' not empty? */
-     do {
-       switch (ls->t.token) {
-         case TK_NAME: {
-@@ -985,6 +985,10 @@ static void parlist (LexState *ls) {
-   luaK_reserveregs(fs, fs->nactvar);  /* reserve registers for parameters */
- }
- 
-+static void parlist (LexState *ls) {
-+  parlist_ext(ls, ')');
-+}
-+
- 
- static void body (LexState *ls, expdesc *e, int ismethod, int line) {
-   /* body ->  '(' parlist ')' block END */
-@@ -1008,6 +1012,25 @@ static void body (LexState *ls, expdesc *e, int ismethod, int line) {
- }
- 
- 
-+static void simplebody (LexState *ls, expdesc *e, int line) {
-+  /* simplebody ->  parlist `|' expr */
-+  FuncState new_fs;
-+  expdesc ebody;
-+  int reg;
-+  BlockCnt bl;
-+  new_fs.f = addprototype(ls);
-+  new_fs.f->linedefined = line;
-+  open_func(ls, &new_fs, &bl);
-+  parlist_ext(ls, '|');
-+  checknext(ls, '|');
-+  expr(ls, &ebody);
-+  reg = luaK_exp2anyreg(&new_fs, &ebody);
-+  luaK_ret(&new_fs, reg, 1);
-+  new_fs.f->lastlinedefined = ls->linenumber;
-+  codeclosure(ls, e);
-+  close_func(ls);
-+}
-+
- static int explist (LexState *ls, expdesc *v) {
-   /* explist -> expr { ',' expr } */
-   int n = 1;  /* at least one expression */
-@@ -1135,7 +1158,6 @@ static void suffixedexp (LexState *ls, expdesc *v) {
-   }
- }
- 
--
- static void simpleexp (LexState *ls, expdesc *v) {
-   /* simpleexp -> FLT | INT | STRING | NIL | TRUE | FALSE | ... |
-                   constructor | FUNCTION body | suffixedexp */
-@@ -1182,6 +1204,11 @@ static void simpleexp (LexState *ls, expdesc *v) {
-       body(ls, v, 0, ls->linenumber);
-       return;
-     }
-+    case '|': {
-+      luaX_next(ls);
-+      simplebody(ls, v, ls->linenumber);
-+      return;
-+    }
-     default: {
-       suffixedexp(ls, v);
-       return;
diff --git a/lambdas.patch b/lambdas.patch
deleted file mode 100644
index d7d7cab..0000000
--- a/lambdas.patch
+++ /dev/null
@@ -1,199 +0,0 @@
-diff --git a/src/llex.c b/src/llex.c
-index 5fc39a5..ac79c27 100644
---- a/src/llex.c
-+++ b/src/llex.c
-@@ -42,6 +42,7 @@ static const char *const luaX_tokens [] = {
-     "end", "false", "for", "function", "goto", "if",
-     "in", "local", "nil", "not", "or", "repeat",
-     "return", "then", "true", "until", "while",
-+    "=>", 
-     "//", "..", "...", "==", ">=", "<=", "~=",
-     "<<", ">>", "::", "<eof>",
-     "<number>", "<integer>", "<name>", "<string>"
-@@ -170,6 +171,8 @@ void luaX_setinput (lua_State *L, LexState *ls, ZIO *z, TString *source,
-   ls->L = L;
-   ls->current = firstchar;
-   ls->lookahead.token = TK_EOS;  /* no look-ahead token */
-+  ls->lookahead2.token = TK_EOS;  /* no look-ahead token */
-+  ls->lookahead3.token = TK_EOS;  /* no look-ahead token */
-   ls->z = z;
-   ls->fs = NULL;
-   ls->linenumber = 1;
-@@ -486,6 +489,7 @@ static int llex (LexState *ls, SemInfo *seminfo) {
-       case '=': {
-         next(ls);
-         if (check_next1(ls, '=')) return TK_EQ;  /* '==' */
-+        else if (check_next1(ls, '>')) return TK_RARROW;  /* '=>' */
-         else return '=';
-       }
-       case '<': {
-@@ -566,7 +570,9 @@ void luaX_next (LexState *ls) {
-   ls->lastline = ls->linenumber;
-   if (ls->lookahead.token != TK_EOS) {  /* is there a look-ahead token? */
-     ls->t = ls->lookahead;  /* use this one */
--    ls->lookahead.token = TK_EOS;  /* and discharge it */
-+    ls->lookahead = ls->lookahead2;
-+    ls->lookahead2 = ls->lookahead3;
-+    ls->lookahead3.token = TK_EOS;  /* and discharge it */
-   }
-   else
-     ls->t.token = llex(ls, &ls->t.seminfo);  /* read next token */
-@@ -574,8 +580,9 @@ void luaX_next (LexState *ls) {
- 
- 
- int luaX_lookahead (LexState *ls) {
--  lua_assert(ls->lookahead.token == TK_EOS);
--  ls->lookahead.token = llex(ls, &ls->lookahead.seminfo);
--  return ls->lookahead.token;
-+  lua_assert(ls->lookahead3.token == TK_EOS);
-+  Token* t = ls->lookahead.token == TK_EOS ? &ls->lookahead : (ls->lookahead2.token == TK_EOS? &ls->lookahead2 : &ls->lookahead3);
-+  t->token = llex(ls, &t->seminfo);
-+  return t->token;
- }
- 
-diff --git a/src/llex.h b/src/llex.h
-index 389d2f8..66dd9b8 100644
---- a/src/llex.h
-+++ b/src/llex.h
-@@ -36,6 +36,7 @@ enum RESERVED {
-   TK_GOTO, TK_IF, TK_IN, TK_LOCAL, TK_NIL, TK_NOT, TK_OR, TK_REPEAT,
-   TK_RETURN, TK_THEN, TK_TRUE, TK_UNTIL, TK_WHILE,
-   /* other terminal symbols */
-+  TK_RARROW,
-   TK_IDIV, TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE,
-   TK_SHL, TK_SHR,
-   TK_DBCOLON, TK_EOS,
-@@ -67,6 +68,8 @@ typedef struct LexState {
-   int lastline;  /* line of last token 'consumed' */
-   Token t;  /* current token */
-   Token lookahead;  /* look ahead token */
-+  Token lookahead2;  /* look ahead token */
-+  Token lookahead3;  /* look ahead token */
-   struct FuncState *fs;  /* current function (parser) */
-   struct lua_State *L;
-   ZIO *z;  /* input stream */
-diff --git a/src/lparser.c b/src/lparser.c
-index 1ac8299..6721483 100644
---- a/src/lparser.c
-+++ b/src/lparser.c
-@@ -955,13 +955,16 @@ static void setvararg (FuncState *fs, int nparams) {
- }
- 
- 
--static void parlist (LexState *ls) {
-+static void parlist (LexState *ls, int parens) {
-   /* parlist -> [ {NAME ','} (NAME | '...') ] */
-   FuncState *fs = ls->fs;
-   Proto *f = fs->f;
-   int nparams = 0;
-   int isvararg = 0;
--  if (ls->t.token != ')') {  /* is 'parlist' not empty? */
-+  if (
-+    (parens && ls->t.token != ')') 
-+    || (!parens && ls->t.token != TK_RARROW && ls->t.token != '{')
-+  ) {  /* is 'parlist' not empty? */
-     do {
-       switch (ls->t.token) {
-         case TK_NAME: {
-@@ -985,24 +988,31 @@ static void parlist (LexState *ls) {
-   luaK_reserveregs(fs, fs->nactvar);  /* reserve registers for parameters */
- }
- 
-+static void singleretstat (LexState* ls);
- 
- static void body (LexState *ls, expdesc *e, int ismethod, int line) {
-   /* body ->  '(' parlist ')' block END */
-   FuncState new_fs;
-   BlockCnt bl;
-+  int parens;
-   new_fs.f = addprototype(ls);
-   new_fs.f->linedefined = line;
-   open_func(ls, &new_fs, &bl);
--  checknext(ls, '(');
-+  parens = testnext(ls, '(');
-   if (ismethod) {
-     new_localvarliteral(ls, "self");  /* create 'self' parameter */
-     adjustlocalvars(ls, 1);
-   }
--  parlist(ls);
--  checknext(ls, ')');
--  statlist(ls);
--  new_fs.f->lastlinedefined = ls->linenumber;
--  check_match(ls, TK_END, TK_FUNCTION, line);
-+  parlist(ls, parens);
-+  if (parens) checknext(ls, ')');
-+  if (testnext(ls, TK_RARROW)) {
-+    singleretstat(ls);
-+   new_fs.f->lastlinedefined = ls->linenumber;
-+  } else {
-+    statlist(ls);
-+    new_fs.f->lastlinedefined = ls->linenumber;
-+    check_match(ls, TK_END, TK_FUNCTION, line);
-+  }
-   codeclosure(ls, e);
-   close_func(ls);
- }
-@@ -1135,6 +1145,16 @@ static void suffixedexp (LexState *ls, expdesc *v) {
-   }
- }
- 
-+static int testlambdadecl (LexState* ls) {
-+int tk = luaX_lookahead(ls);
-+  if (tk == ')') return 1;
-+  else if (tk != TK_NAME) return 0;
-+  tk = luaX_lookahead(ls);
-+  if (tk == ',') return 1;
-+  else if (tk != ')') return 0;
-+  tk = luaX_lookahead(ls);
-+  return tk == TK_RARROW;
-+}
- 
- static void simpleexp (LexState *ls, expdesc *v) {
-   /* simpleexp -> FLT | INT | STRING | NIL | TRUE | FALSE | ... |
-@@ -1182,6 +1202,24 @@ static void simpleexp (LexState *ls, expdesc *v) {
-       body(ls, v, 0, ls->linenumber);
-       return;
-     }
-+    case TK_RARROW: {
-+      body(ls, v, 0, ls->linenumber);
-+      return;
-+    }
-+    case TK_NAME: {
-+      if (luaX_lookahead(ls) == TK_RARROW)
-+        body(ls, v, 0, ls->linenumber);
-+      else
-+        suffixedexp(ls, v);
-+      return;
-+    }
-+    case '(': {
-+      if (testlambdadecl(ls)) 
-+        body(ls, v, 0, ls->linenumber);
-+      else
-+        suffixedexp(ls, v);
-+      return;
-+    }
-     default: {
-       suffixedexp(ls, v);
-       return;
-@@ -1840,6 +1878,21 @@ static void retstat (LexState *ls) {
-   testnext(ls, ';');  /* skip optional semicolon */
- }
- 
-+static void singleretstat (LexState* ls) {
-+expdesc e;
-+int line = ls->linenumber;
-+if (testnext(ls, '(')) {
-+retstat(ls);
-+check_match(ls, ')', '(', line);
-+}
-+else {
-+expr(ls, &e);
-+  int first = luaY_nvarstack(ls->fs);  /* first slot to be returned */
-+        first = luaK_exp2anyreg(ls->fs, &e);  /* can use original slot */
-+  luaK_ret(ls->fs, first, 1);
-+}
-+}
-+
- 
- static void statement (LexState *ls) {
-   int line = ls->linenumber;  /* may be needed for error messages */
diff --git a/methods-in-tables.patch b/methods-in-tables.patch
deleted file mode 100644
index 2df1f1e..0000000
--- a/methods-in-tables.patch
+++ /dev/null
@@ -1,79 +0,0 @@
-diff --git a/src/lparser.c b/src/lparser.c
-index 1ac8299..6399e3e 100644
---- a/src/lparser.c
-+++ b/src/lparser.c
-@@ -863,6 +863,24 @@ static void recfield (LexState *ls, ConsControl *cc) {
-   fs->freereg = reg;  /* free registers */
- }
- 
-+static void body (LexState *ls, expdesc *e, int ismethod, int line);
-+
-+static int funcfield (LexState *ls, ConsControl *cc) {
-+  /* funcfield -> FUNCTION funcname body */
-+  FuncState *fs = ls->fs;
-+  int reg = ls->fs->freereg;
-+  expdesc tab, key, b;
-+  luaX_next(ls);  /* skip FUNCTION */
-+    checklimit(fs, cc->nh, MAX_INT, "items in a constructor");
-+    codename(ls, &key);
-+  cc->nh++;
-+  tab = *cc->t;
-+  luaK_indexed(fs, &tab, &key);
-+  body(ls, &b, 1, ls->linenumber);
-+  luaK_storevar(fs, &tab, &b);
-+  fs->freereg = reg;  /* free registers */
-+  return 1;
-+}
- 
- static void closelistfield (FuncState *fs, ConsControl *cc) {
-   if (cc->v.k == VVOID) return;  /* there is no list item */
-@@ -899,8 +917,9 @@ static void listfield (LexState *ls, ConsControl *cc) {
- }
- 
- 
--static void field (LexState *ls, ConsControl *cc) {
-+static int field (LexState *ls, ConsControl *cc) {
-   /* field -> listfield | recfield */
-+  int nocomma = 0;
-   switch(ls->t.token) {
-     case TK_NAME: {  /* may be 'listfield' or 'recfield' */
-       if (luaX_lookahead(ls) != '=')  /* expression? */
-@@ -913,11 +932,19 @@ static void field (LexState *ls, ConsControl *cc) {
-       recfield(ls, cc);
-       break;
-     }
-+    case TK_FUNCTION: {
-+      if (luaX_lookahead(ls) != TK_NAME)  
-+        listfield(ls, cc);
-+      else
-+        nocomma = funcfield(ls, cc);
-+      break;
-+    }
-     default: {
-       listfield(ls, cc);
-       break;
-     }
-   }
-+  return nocomma;
- }
- 
- 
-@@ -927,6 +954,7 @@ static void constructor (LexState *ls, expdesc *t) {
-   FuncState *fs = ls->fs;
-   int line = ls->linenumber;
-   int pc = luaK_codeABC(fs, OP_NEWTABLE, 0, 0, 0);
-+  int nocomma = 0;
-   ConsControl cc;
-   luaK_code(fs, 0);  /* space for extra arg. */
-   cc.na = cc.nh = cc.tostore = 0;
-@@ -939,8 +967,8 @@ static void constructor (LexState *ls, expdesc *t) {
-     lua_assert(cc.v.k == VVOID || cc.tostore > 0);
-     if (ls->t.token == '}') break;
-     closelistfield(fs, &cc);
--    field(ls, &cc);
--  } while (testnext(ls, ',') || testnext(ls, ';'));
-+    nocomma = field(ls, &cc);
-+  } while (testnext(ls, ',') || testnext(ls, ';') || nocomma);
-   check_match(ls, '}', '{', line);
-   lastlistfield(fs, &cc);
-   luaK_settablesize(fs, pc, t->u.info, cc.na, cc.nh);
diff --git a/semicolon-expand.patch b/semicolon-expand.patch
deleted file mode 100644
index 35470e3..0000000
--- a/semicolon-expand.patch
+++ /dev/null
@@ -1,109 +0,0 @@
-diff --git a/src/lcode.c b/src/lcode.c
-index 3f78370..bda68f9 100644
---- a/src/lcode.c
-+++ b/src/lcode.c
-@@ -1812,6 +1812,7 @@ void luaK_setlist (FuncState *fs, int base, int nelems, int tostore) {
-   lua_assert(tostore != 0 && tostore <= LFIELDS_PER_FLUSH);
-   if (tostore == LUA_MULTRET)
-     tostore = 0;
-+    nelems++;
-   if (nelems <= MAXARG_C)
-     luaK_codeABC(fs, OP_SETLIST, base, tostore, nelems);
-   else {
-diff --git a/src/lparser.c b/src/lparser.c
-index 1ac8299..c617a50 100644
---- a/src/lparser.c
-+++ b/src/lparser.c
-@@ -841,6 +841,7 @@ typedef struct ConsControl {
-   int nh;  /* total number of 'record' elements */
-   int na;  /* number of array elements already stored */
-   int tostore;  /* number of array elements pending to be stored */
-+  int naundef; /* non-zero if exact number of elements not known */
- } ConsControl;
- 
- 
-@@ -869,7 +870,7 @@ static void closelistfield (FuncState *fs, ConsControl *cc) {
-   luaK_exp2nextreg(fs, &cc->v);
-   cc->v.k = VVOID;
-   if (cc->tostore == LFIELDS_PER_FLUSH) {
--    luaK_setlist(fs, cc->t->u.info, cc->na, cc->tostore);  /* flush */
-+    luaK_setlist(fs, cc->t->u.info, cc->naundef? LUA_MULTRET  : cc->na, cc->tostore);  /* flush */
-     cc->na += cc->tostore;
-     cc->tostore = 0;  /* no more items pending */
-   }
-@@ -880,15 +881,16 @@ static void lastlistfield (FuncState *fs, ConsControl *cc) {
-   if (cc->tostore == 0) return;
-   if (hasmultret(cc->v.k)) {
-     luaK_setmultret(fs, &cc->v);
--    luaK_setlist(fs, cc->t->u.info, cc->na, LUA_MULTRET);
-+    luaK_setlist(fs, cc->t->u.info, cc->naundef? LUA_MULTRET : cc->na, LUA_MULTRET);
-     cc->na--;  /* do not count last expression (unknown number of elements) */
-   }
-   else {
-     if (cc->v.k != VVOID)
-       luaK_exp2nextreg(fs, &cc->v);
--    luaK_setlist(fs, cc->t->u.info, cc->na, cc->tostore);
-+    luaK_setlist(fs, cc->t->u.info, cc->naundef? LUA_MULTRET : cc->na, cc->tostore);
-   }
-   cc->na += cc->tostore;
-+  cc->tostore = 0;
- }
- 
- 
-@@ -927,9 +929,10 @@ static void constructor (LexState *ls, expdesc *t) {
-   FuncState *fs = ls->fs;
-   int line = ls->linenumber;
-   int pc = luaK_codeABC(fs, OP_NEWTABLE, 0, 0, 0);
-+int doflush = 0;
-   ConsControl cc;
-   luaK_code(fs, 0);  /* space for extra arg. */
--  cc.na = cc.nh = cc.tostore = 0;
-+  cc.na = cc.nh = cc.tostore = cc.naundef = 0;
-   cc.t = t;
-   init_exp(t, VNONRELOC, fs->freereg);  /* table will be at stack top */
-   luaK_reserveregs(fs, 1);
-@@ -938,9 +941,14 @@ static void constructor (LexState *ls, expdesc *t) {
-   do {
-     lua_assert(cc.v.k == VVOID || cc.tostore > 0);
-     if (ls->t.token == '}') break;
--    closelistfield(fs, &cc);
-+    if (doflush && cc.tostore>0 && hasmultret(cc.v.k)) {
-+      lastlistfield(fs, &cc);
-+      cc.naundef=1;
-+    }
-+    else closelistfield(fs, &cc);
-+    doflush = 0;
-     field(ls, &cc);
--  } while (testnext(ls, ',') || testnext(ls, ';'));
-+  } while (testnext(ls, ',') || (doflush = testnext(ls, ';')) );
-   check_match(ls, '}', '{', line);
-   lastlistfield(fs, &cc);
-   luaK_settablesize(fs, pc, t->u.info, cc.na, cc.nh);
-diff --git a/src/lvm.c b/src/lvm.c
-index 7023a04..285c63a 100644
---- a/src/lvm.c
-+++ b/src/lvm.c
-@@ -1850,6 +1850,8 @@ void luaV_execute (lua_State *L, CallInfo *ci) {
-         int n = GETARG_B(i);
-         unsigned int last = GETARG_C(i);
-         Table *h = hvalue(s2v(ra));
-+        if (last == 0)
-+          last = luaH_getn(h) + 1;
-         if (n == 0)
-           n = cast_int(L->top.p - ra) - 1;  /* get up to the top */
-         else
-@@ -1859,12 +1861,11 @@ void luaV_execute (lua_State *L, CallInfo *ci) {
-           last += GETARG_Ax(*pc) * (MAXARG_C + 1);
-           pc++;
-         }
--        if (last > luaH_realasize(h))  /* needs more space? */
-+        if (--last > luaH_realasize(h))  /* needs more space? */
-           luaH_resizearray(L, h, last);  /* preallocate it at once */
-         for (; n > 0; n--) {
-           TValue *val = s2v(ra + n);
--          setobj2t(L, &h->array[last - 1], val);
--          last--;
-+          setobj2t(L, &h->array[--last], val);
-           luaC_barrierback(L, obj2gco(h), val);
-         }
-         vmbreak;
diff --git a/shorter-table-items.patch b/shorter-table-items.patch
deleted file mode 100644
index 1031aad..0000000
--- a/shorter-table-items.patch
+++ /dev/null
@@ -1,55 +0,0 @@
-diff --git a/src/lparser.c b/src/lparser.c
-index 1ac8299..c76b120 100644
---- a/src/lparser.c
-+++ b/src/lparser.c
-@@ -855,7 +855,25 @@ static void recfield (LexState *ls, ConsControl *cc) {
-     yindex(ls, &key);
-   checklimit(fs, cc->nh, MAX_INT, "items in a constructor");
-   cc->nh++;
-+  tab = *cc->t;
-+  luaK_indexed(fs, &tab, &key);
-+    if (testnext(ls, '=')) expr(ls, &val);
-+  else init_exp(&val, VTRUE, 0);
-+  luaK_storevar(fs, &tab, &val);
-+  fs->freereg = reg;  /* free registers */
-+}
-+
-+static void shortrecfield (LexState *ls, ConsControl *cc) {
-+  /* shortrecfield -> = exp */
-+  FuncState *fs = ls->fs;
-+  int reg = ls->fs->freereg;
-+  expdesc tab, key, val;
-   checknext(ls, '=');
-+  check(ls, TK_NAME);
-+  ls->lookahead = ls->t;
-+    checklimit(fs, cc->nh, MAX_INT, "items in a constructor");
-+    codename(ls, &key);
-+  cc->nh++;
-   tab = *cc->t;
-   luaK_indexed(fs, &tab, &key);
-   expr(ls, &val);
-@@ -863,7 +881,6 @@ static void recfield (LexState *ls, ConsControl *cc) {
-   fs->freereg = reg;  /* free registers */
- }
- 
--
- static void closelistfield (FuncState *fs, ConsControl *cc) {
-   if (cc->v.k == VVOID) return;  /* there is no list item */
-   luaK_exp2nextreg(fs, &cc->v);
-@@ -909,10 +926,16 @@ static void field (LexState *ls, ConsControl *cc) {
-         recfield(ls, cc);
-       break;
-     }
-+    case '.':
-+      luaX_next(ls); // fallthrough
-     case '[': {
-       recfield(ls, cc);
-       break;
-     }
-+    case '=': {
-+      shortrecfield(ls, cc);
-+      break;
-+    }
-     default: {
-       listfield(ls, cc);
-       break;
diff --git a/src/lparser.c b/src/lparser.c
index 1ac8299..a24ebdf 100644
--- a/src/lparser.c
+++ b/src/lparser.c
@@ -1008,11 +1008,15 @@ static void body (LexState *ls, expdesc *e, int ismethod, int line) {
 }
 
 
-static int explist (LexState *ls, expdesc *v) {
+static int explist (LexState *ls, expdesc *v, int* cont) {
   /* explist -> expr { ',' expr } */
   int n = 1;  /* at least one expression */
   expr(ls, v);
   while (testnext(ls, ',')) {
+    if (cont && ls->t.token==TK_NAME && luaX_lookahead(ls) == '=') {
+      *cont = 1;
+      break;
+    }
     luaK_exp2nextreg(ls->fs, v);
     expr(ls, v);
     n++;
@@ -1032,7 +1036,7 @@ static void funcargs (LexState *ls, expdesc *f) {
       if (ls->t.token == ')')  /* arg list is empty? */
         args.k = VVOID;
       else {
-        explist(ls, &args);
+        explist(ls, &args, NULL);
         if (hasmultret(args.k))
           luaK_setmultret(fs, &args);
       }
@@ -1388,7 +1392,7 @@ static void restassign (LexState *ls, struct LHS_assign *lh, int nvars) {
   else {  /* restassign -> '=' explist */
     int nexps;
     checknext(ls, '=');
-    nexps = explist(ls, &e);
+    nexps = explist(ls, &e, NULL);
     if (nexps != nvars)
       adjust_assign(ls, nvars, nexps, &e);
     else {
@@ -1608,7 +1612,7 @@ static void forlist (LexState *ls, TString *indexname) {
   }
   checknext(ls, TK_IN);
   line = ls->linenumber;
-  adjust_assign(ls, 4, explist(ls, &e), &e);
+  adjust_assign(ls, 4, explist(ls, &e, NULL), &e);
   adjustlocalvars(ls, 4);  /* control variables */
   marktobeclosed(fs);  /* last control var. must be closed */
   luaK_checkstack(fs, 3);  /* extra space to call generator */
@@ -1723,9 +1727,9 @@ static void checktoclose (FuncState *fs, int level) {
 
 
 static void localstat (LexState *ls) {
-  /* stat -> LOCAL NAME ATTRIB { ',' NAME ATTRIB } ['=' explist] */
+  begin: /* stat -> LOCAL NAME ATTRIB { ',' NAME ATTRIB } ['=' explist] */
   FuncState *fs = ls->fs;
-  int toclose = -1;  /* index of to-be-closed variable (if any) */
+  int toclose = -1, cont = 0;  /* index of to-be-closed variable (if any) */
   Vardesc *var;  /* last variable */
   int vidx, kind;  /* index and kind of last variable */
   int nvars = 0;
@@ -1743,7 +1747,7 @@ static void localstat (LexState *ls) {
     nvars++;
   } while (testnext(ls, ','));
   if (testnext(ls, '='))
-    nexps = explist(ls, &e);
+    nexps = explist(ls, &e, &cont);
   else {
     e.k = VVOID;
     nexps = 0;
@@ -1761,6 +1765,7 @@ static void localstat (LexState *ls) {
     adjustlocalvars(ls, nvars);
   }
   checktoclose(fs, toclose);
+  if (cont) goto begin;
 }
 
 
@@ -1818,7 +1823,7 @@ static void retstat (LexState *ls) {
   if (block_follow(ls, 1) || ls->t.token == ';')
     nret = 0;  /* return no values */
   else {
-    nret = explist(ls, &e);  /* optional return values */
+    nret = explist(ls, &e, NULL);  /* optional return values */
     if (hasmultret(e.k)) {
       luaK_setmultret(fs, &e);
       if (e.k == VCALL && nret == 1 && !fs->bl->insidetbc) {  /* tail call? */
diff --git a/star-expand.patch b/star-expand.patch
deleted file mode 100644
index 3d01934..0000000
--- a/star-expand.patch
+++ /dev/null
@@ -1,109 +0,0 @@
-diff --git a/src/lcode.c b/src/lcode.c
-index 3f78370..bda68f9 100644
---- a/src/lcode.c
-+++ b/src/lcode.c
-@@ -1812,6 +1812,7 @@ void luaK_setlist (FuncState *fs, int base, int nelems, int tostore) {
-   lua_assert(tostore != 0 && tostore <= LFIELDS_PER_FLUSH);
-   if (tostore == LUA_MULTRET)
-     tostore = 0;
-+    nelems++;
-   if (nelems <= MAXARG_C)
-     luaK_codeABC(fs, OP_SETLIST, base, tostore, nelems);
-   else {
-diff --git a/src/lparser.c b/src/lparser.c
-index 1ac8299..28da055 100644
---- a/src/lparser.c
-+++ b/src/lparser.c
-@@ -841,6 +841,7 @@ typedef struct ConsControl {
-   int nh;  /* total number of 'record' elements */
-   int na;  /* number of array elements already stored */
-   int tostore;  /* number of array elements pending to be stored */
-+  int naundef; /* non-zero if exact number of elements not known */
- } ConsControl;
- 
- 
-@@ -869,7 +870,7 @@ static void closelistfield (FuncState *fs, ConsControl *cc) {
-   luaK_exp2nextreg(fs, &cc->v);
-   cc->v.k = VVOID;
-   if (cc->tostore == LFIELDS_PER_FLUSH) {
--    luaK_setlist(fs, cc->t->u.info, cc->na, cc->tostore);  /* flush */
-+    luaK_setlist(fs, cc->t->u.info, cc->naundef? LUA_MULTRET  : cc->na, cc->tostore);  /* flush */
-     cc->na += cc->tostore;
-     cc->tostore = 0;  /* no more items pending */
-   }
-@@ -880,15 +881,16 @@ static void lastlistfield (FuncState *fs, ConsControl *cc) {
-   if (cc->tostore == 0) return;
-   if (hasmultret(cc->v.k)) {
-     luaK_setmultret(fs, &cc->v);
--    luaK_setlist(fs, cc->t->u.info, cc->na, LUA_MULTRET);
-+    luaK_setlist(fs, cc->t->u.info, cc->naundef? LUA_MULTRET : cc->na, LUA_MULTRET);
-     cc->na--;  /* do not count last expression (unknown number of elements) */
-   }
-   else {
-     if (cc->v.k != VVOID)
-       luaK_exp2nextreg(fs, &cc->v);
--    luaK_setlist(fs, cc->t->u.info, cc->na, cc->tostore);
-+    luaK_setlist(fs, cc->t->u.info, cc->naundef? LUA_MULTRET : cc->na, cc->tostore);
-   }
-   cc->na += cc->tostore;
-+  cc->tostore = 0;
- }
- 
- 
-@@ -927,9 +929,10 @@ static void constructor (LexState *ls, expdesc *t) {
-   FuncState *fs = ls->fs;
-   int line = ls->linenumber;
-   int pc = luaK_codeABC(fs, OP_NEWTABLE, 0, 0, 0);
-+int doflush = 0;
-   ConsControl cc;
-   luaK_code(fs, 0);  /* space for extra arg. */
--  cc.na = cc.nh = cc.tostore = 0;
-+  cc.na = cc.nh = cc.tostore = cc.naundef = 0;
-   cc.t = t;
-   init_exp(t, VNONRELOC, fs->freereg);  /* table will be at stack top */
-   luaK_reserveregs(fs, 1);
-@@ -938,9 +941,14 @@ static void constructor (LexState *ls, expdesc *t) {
-   do {
-     lua_assert(cc.v.k == VVOID || cc.tostore > 0);
-     if (ls->t.token == '}') break;
--    closelistfield(fs, &cc);
-+    if (doflush && cc.tostore>0 && hasmultret(cc.v.k)) {
-+      lastlistfield(fs, &cc);
-+      cc.naundef=1;
-+    }
-+    else closelistfield(fs, &cc);
-+    doflush = testnext(ls, '*');
-     field(ls, &cc);
--  } while (testnext(ls, ',') || testnext(ls, ';'));
-+  } while (testnext(ls, ',') || testnext(ls, ';') );
-   check_match(ls, '}', '{', line);
-   lastlistfield(fs, &cc);
-   luaK_settablesize(fs, pc, t->u.info, cc.na, cc.nh);
-diff --git a/src/lvm.c b/src/lvm.c
-index 7023a04..285c63a 100644
---- a/src/lvm.c
-+++ b/src/lvm.c
-@@ -1850,6 +1850,8 @@ void luaV_execute (lua_State *L, CallInfo *ci) {
-         int n = GETARG_B(i);
-         unsigned int last = GETARG_C(i);
-         Table *h = hvalue(s2v(ra));
-+        if (last == 0)
-+          last = luaH_getn(h) + 1;
-         if (n == 0)
-           n = cast_int(L->top.p - ra) - 1;  /* get up to the top */
-         else
-@@ -1859,12 +1861,11 @@ void luaV_execute (lua_State *L, CallInfo *ci) {
-           last += GETARG_Ax(*pc) * (MAXARG_C + 1);
-           pc++;
-         }
--        if (last > luaH_realasize(h))  /* needs more space? */
-+        if (--last > luaH_realasize(h))  /* needs more space? */
-           luaH_resizearray(L, h, last);  /* preallocate it at once */
-         for (; n > 0; n--) {
-           TValue *val = s2v(ra + n);
--          setobj2t(L, &h->array[last - 1], val);
--          last--;
-+          setobj2t(L, &h->array[--last], val);
-           luaC_barrierback(L, obj2gco(h), val);
-         }
-         vmbreak;
diff --git a/table-extract.patch b/table-extract.patch
deleted file mode 100644
index f3b7d1d..0000000
--- a/table-extract.patch
+++ /dev/null
@@ -1,55 +0,0 @@
-diff --git a/src/lcode.c b/src/lcode.c
-index 3f78370..9b06787 100644
---- a/src/lcode.c
-+++ b/src/lcode.c
-@@ -997,7 +997,7 @@ void luaK_exp2val (FuncState *fs, expdesc *e) {
- ** Try to make 'e' a K expression with an index in the range of R/K
- ** indices. Return true iff succeeded.
- */
--static int luaK_exp2K (FuncState *fs, expdesc *e) {
-+/*static*/ int luaK_exp2K (FuncState *fs, expdesc *e) {
-   if (!hasjumps(e)) {
-     int info;
-     switch (e->k) {  /* move constants to 'k' */
-diff --git a/src/lparser.c b/src/lparser.c
-index 1ac8299..af9544d 100644
---- a/src/lparser.c
-+++ b/src/lparser.c
-@@ -1721,6 +1721,26 @@ static void checktoclose (FuncState *fs, int level) {
-   }
- }
- 
-+static void extractlocal (LexState* ls, int nvars) {
-+FuncState* fs = ls->fs;
-+expdesc e, v;
-+  Vardesc *var;
-+int firstvar = fs->nactvar;
-+      luaK_nil(fs, fs->freereg, nvars);
-+    adjustlocalvars(ls, nvars);
-+  luaK_checkstack(fs, 1);
-+fs->freereg += nvars;
-+expr(ls, &e);
-+fs->freereg -= nvars;
-+init_exp(&v, VLOCAL, firstvar + nvars);
-+luaK_storevar(fs, &v, &e);
-+for (int i=0; i<nvars; i++) {
-+  var = getlocalvardesc(fs, firstvar+i);
-+codestring(&e, var->vd.name);
-+luaK_exp2K(fs, &e);
-+luaK_codeABC(fs, OP_GETFIELD, var->vd.ridx, firstvar + nvars, e.u.info);
-+}
-+}
- 
- static void localstat (LexState *ls) {
-   /* stat -> LOCAL NAME ATTRIB { ',' NAME ATTRIB } ['=' explist] */
-@@ -1744,6 +1764,10 @@ static void localstat (LexState *ls) {
-   } while (testnext(ls, ','));
-   if (testnext(ls, '='))
-     nexps = explist(ls, &e);
-+  else if (testnext(ls, TK_IN)) {
-+extractlocal(ls, nvars);
-+return;
-+  }
-   else {
-     e.k = VVOID;
-     nexps = 0;
